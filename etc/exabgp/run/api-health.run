#!/usr/bin/env python3

import json
import os
import select
import signal
import sys
import time


def main() -> None:
    try:
        # Wait for BGP session to establish
        time.sleep(2)

        # Test ping command
        flush('ping\n')

        # Read response (JSON format by default)
        response = sys.stdin.readline().strip()

        # Try to parse as JSON first (new default format)
        try:
            data = json.loads(response)
            if 'pong' not in data or 'active' not in data:
                fail(f'ERROR: ping response missing required fields, got: {response}\n')
                sys.exit(1)
            uuid = data['pong']
            active = data['active']
            fail(f'OK: ping returned UUID {uuid} (active={active})\n')
        except (json.JSONDecodeError, ValueError):
            # Fallback to text format (legacy)
            if not response.startswith('pong '):
                fail(f'ERROR: ping failed, got: {response}\n')
                sys.exit(1)
            uuid = response.split()[1]
            fail(f'OK: ping returned UUID {uuid}\n')

        # Read done
        done = sys.stdin.readline().strip()
        if done != 'done':
            fail(f'ERROR: expected done, got: {done}\n')
            sys.exit(1)

        # Announce route after successful ping
        flush('announce route 192.168.0.1/32 next-hop 10.0.0.1\n')
        wait_for_ack()
        time.sleep(0.1)

        # Test status command
        flush('status\n')

        # Read multi-line response
        status_lines = []
        while True:
            line = sys.stdin.readline().strip()
            if line == 'done':
                break
            status_lines.append(line)

        status_text = '\n'.join(status_lines)
        if 'UUID' not in status_text and uuid not in status_text:
            fail(f'ERROR: status missing UUID, got: {status_text}\n')
            sys.exit(1)

        if 'PID' not in status_text:
            fail('ERROR: status missing PID\n')
            sys.exit(1)

        fail('OK: status returned complete information\n')

        # Announce route after successful status
        flush('announce route 192.168.0.2/32 next-hop 10.0.0.2\n')
        wait_for_ack()
        time.sleep(0.1)

        fail('SUCCESS: Health monitoring commands working\n')

        # Wait for shutdown signal (like other api-* tests)
        now = time.time()
        while os.getppid() != 1 and time.time() < now + 7:
            line = sys.stdin.readline().strip()
            if not line or 'shutdown' in line:
                break
            time.sleep(0.1)
    except IOError:
        pass


def wait_for_ack(expected_count: int = 1, timeout: int = 2) -> bool:
    """Wait for ACK responses from ExaBGP."""
    received = 0
    start_time = time.time()

    while received < expected_count:
        elapsed = time.time() - start_time
        if elapsed >= timeout:
            return False

        ready, _, _ = select.select([sys.stdin], [], [], 0.1)
        if ready:
            line = sys.stdin.readline().strip()
            answer = None
            if line.startswith('{'):
                try:
                    data = json.loads(line)
                    answer = data.get('answer')
                except (json.JSONDecodeError, ValueError):
                    pass
            else:
                answer = line

            if answer == 'done':
                received += 1
            elif answer == 'error':
                return False
            elif answer == 'shutdown':
                raise SystemExit(0)
        else:
            time.sleep(0.1)

    return True


def flush(msg: str) -> None:
    """Write message to stdout and flush."""
    sys.stdout.write(msg)
    sys.stdout.flush()


def fail(msg: str) -> None:
    """Write error message to stderr and flush."""
    sys.stderr.write(msg)
    sys.stderr.flush()


if __name__ == '__main__':
    signal.signal(signal.SIGPIPE, signal.SIG_DFL)
    main()
