#!/usr/bin/env python3

import os
import sys
import time
import select
import json

# Wait for ExaBGP to initialize
time.sleep(1)


def wait_for_ack(expected_count=1, timeout=2):
    """
    Wait for ACK responses from ExaBGP.

    Polls STDIN until all expected ACK messages are received.
    ExaBGP may not respond immediately, so we loop with sleep.

    Handles both text and JSON encoder formats:
    - Text: "done", "error", "shutdown"
    - JSON: {"answer": "done|error|shutdown", "message": "..."}

    Args:
        expected_count: Number of ACK messages expected (default: 1)
        timeout: Total timeout in seconds (default: 2)

    Returns:
        True if all ACKs received successfully
        False if any command failed or timeout occurred

    Raises:
        SystemExit: If ExaBGP sends shutdown message
    """
    import json

    received = 0
    start_time = time.time()

    while received < expected_count:
        # Check if we've exceeded timeout
        elapsed = time.time() - start_time
        if elapsed >= timeout:
            return False

        # Poll for data (non-blocking with short timeout)
        ready, _, _ = select.select([sys.stdin], [], [], 0.1)

        if ready:
            line = sys.stdin.readline().strip()

            # Parse response (could be text or JSON)
            answer = None
            if line.startswith('{'):
                # JSON format: {"answer": "done|error|shutdown", ...}
                try:
                    data = json.loads(line)
                    answer = data.get('answer')
                except:
                    pass
            else:
                # Text format: done|error|shutdown
                answer = line

            if answer == 'done':
                received += 1
            elif answer == 'error':
                return False
            elif answer == 'shutdown':
                raise SystemExit(0)
            # Ignore other messages (could be BGP updates if receiving)
        else:
            # No data yet, sleep briefly before next poll
            time.sleep(0.1)

    return True


# Test dynamic peer lifecycle (create) + route announcement
# This test creates a neighbor dynamically (without pre-configured neighbor)
try:
    messages = [
        # 1. Create dynamic peer (127.0.0.1) - API format: create neighbor ...
        #    This peer WILL connect to the test server and allow route announcement
        'create neighbor 127.0.0.1 local-address 127.0.0.1 local-as 1 peer-as 1 router-id 1.2.3.4 api peer-lifecycle',

        # 2. Announce route to dynamic peer (127.0.0.1)
        #    This route will be sent and validated by test server
        'announce route 1.1.0.0/24 next-hop 101.101.101.101',

        # 3. Add invalid announce to force server to show what it received
        #    The test server will stop after receiving expected messages and show output
        'announce route 999.999.999.999/32 next-hop 1.1.1.1',
    ]

    for message in messages:
        sys.stdout.write(message + '\n')
        sys.stdout.flush()
        # Wait for ACK
        if not wait_for_ack(expected_count=1, timeout=2):
            # ACK not received, continuing anyway (ACKs may be disabled in config)
            pass
        time.sleep(0.2)

    # Give server brief time to validate messages and stop
    time.sleep(0.5)

    # Send shutdown command to terminate ExaBGP gracefully
    sys.stdout.write('shutdown\n')
    sys.stdout.flush()
except (IOError, BrokenPipeError, EOFError):
    # Expected when ExaBGP shuts down
    pass
