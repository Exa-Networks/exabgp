#!/usr/bin/env python3

import re
import os
import sys
import json
import shutil
import pprint
import urllib.request
from glob import glob

from pygments.token import Token
from yanglexer import yanglexer


DEBUG = True


def write(string):
    if not string.startswith('\n'):
        fill = ' ' * shutil.get_terminal_size().columns
        sys.stdout.write(f'\r{fill}\r')
    sys.stdout.write(f'{string}')
    sys.stdout.flush()


class yang:
    types = (
        'binary',
        'bits',
        'boolean',
        'decimal64',
        'empty',
        'enumeration',
        'identityref',
        'instance-identifier',
        'int8',
        'int16',
        'int32',
        'int64',
        'leafref',
        'string',
        'uint8',
        'uint16',
        'uint32',
        'uint64',
        'union',
    )

    words = (
        'extension',
        'yang-version',
        'namespace',
        'prefix',
        'description',
        'import',
        'organization',
        'contact',
        'description',
        'revision',
        'typedef',
        'type',
        'enumeration',
        'range',
        'length',
        'grouping',
        'leaf',
        'leaf-list',
        'enum',
        'default',
        'key',
        'mandatory',
        'refine',
        'uses',
        'list',
        'container',
        'union',
        'value',
        'reference',
        'pattern',
    )

    # the yang keywords
    kw = dict((w, f'[{w}]') for w in words)
    # the yang module loaded
    kw['loaded'] = '[loaded]'
    # the root of the configuration
    kw['root'] = '[root]'
    # strings can be pattern but is assume to be a match otherwise, make it explicit
    kw['match'] = '[match]'

    ranges = {
        'int8': (0, pow(2, 8)-1),
        'int16': (0, pow(2, 16)-1),
        'int32': (0, pow(2, 32)-1),
        'int64': (0, pow(2, 64)-1),
        'uint8': (-pow(2, 7), pow(2, 7)-1),
        'uint16': (-pow(2, 7), pow(2, 15)-1),
        'uint32': (-pow(2, 7), pow(2, 31)-1),
        'uint64': (-pow(2, 7), pow(2, 64)-1),
    }

    namespaces = {
        'ietf': 'https://raw.githubusercontent.com/YangModels/yang/master/standard/ietf/RFC',
    }

    # initialised by load
    # this is a namespace / singleton, and should not be used as instance
    models = {}
    folder = ''

    @classmethod
    def load(cls, library, folder):
        cls.folder = folder
        if not cls.models:
            models = json.loads(open(library).read())

        for m in models['ietf-yang-library:modules-state']['module']:
            cls.models[m['name']] = m

    @classmethod
    def fetch_models(cls, folder):
        print('downloading models')

        for module in cls.models:
            cls.fetch_model(folder, module)

        print('done.\n')

    @classmethod
    def fetch_model(cls, folder, name):
        if not os.path.exists('models'):
            os.mkdir('models')

        if name not in cls.models:
            sys.exit(f'{module} imported but not defined in yang-library-data.json')

        module = cls.models[name]

        revision = module['revision']
        yang = f'{name}@{revision}.yang'
        save = f'{folder}/{name}.yang'

        if 'schema' in module:
            url = module['schema']

        elif 'namespace' in module:
            namespace = module['namespace'].split(':')
            site = cls.namespaces.get(namespace[1], '')
            if not site:
                raise RuntimeError('unimplemented namespace case')

            url = f"{site}/{yang}"
        else:
            raise RuntimeError('unimplemented yang-library case')

        if os.path.exists(save):
            write(f'ðŸ‘Œ skipping {name} (already downloaded)')
            if cls._verify(name, save):
                write('\n')
                return

        write(f'ðŸ‘ï¸  retrieve {name}@{revision} ({url})')

        try:
            urllib.request.urlretrieve(url, save)
            # indirect = urllib.request.urlopen(schema).read()
        except urllib.error.HTTPError as exc:
            write(f'\nðŸ¥º failure attempting to retrieve {url}\n{exc}')
            return

        if not cls._verify(name, save):
            sys.exit(f'\ninvalid yang content for {name}@{revision}')

        write(f'ðŸ‘ retrieve {name}@{revision}\n')

    @staticmethod
    def _verify(name, save):
        # simple but should be enough
        write(f'ðŸ” checking {name} for correct yaml')
        if not open(save).readline().startswith('module'):
            write(f'ðŸ¥µ not-yang {name} does not contain a yang module')
            return False
        return True

    @classmethod
    def clean_models(cls):
        print(f'cleaning {cls.folder}')
        for file in glob(f'{cls.folder}/*.yang'):
            print(f'cleanup: {file}')
            os.remove(file)
        print('done.\n')


class Lexer(object):
    ignore = (Token.Text, Token.Comment.Singleline)

    @staticmethod
    def formated(string):
        s = string.strip()
        if s and s[0] == s[-1]:
            if s[0] in ('"', "'"):
                s = s[1:-1]
        s = re.sub(r'\n\t*\s*', ' ', s)
        return s

    def __init__(self, yangfile):
        name = yangfile.split('/')[-1].split('.')[0]
        # the yang file parsed tokens (configuration block according to the syntax)
        self.tokens = []
        # the name of the module being parsed
        self.module = ''
        # module can declare a "prefix" (nickname), which can be used to make the syntax shorter
        self.prefix = ''
        # the parsed yang tree
        # - at the root are the namespace (the module names) and within
        #   * a key for all the typedef
        #   * a key for all the grouping
        #   * a key for the root of the configuration
        # - a key [loaded] with a list of the module loaded (first is the one parsed)
        # the names of all the configuration sections
        self.tree = {}
        # the current namespace (module) we are parsing
        self.ns = {}
        # where the grouping for this section are stored
        self.grouping = {}
        # where the typedef for this section are stored
        self.typedef = {}
        # where the configuration parsed is stored
        self.root = {}
        self.load(name, yangfile)

    def tokenise(self, name):
        lexer = yanglexer.YangLexer()
        content = open(name).read()
        tokens = lexer.get_tokens(content)
        return [(t, n) for (t, n) in tokens if t not in self.ignore]

    def unexpected(self, string):
        pprint.pprint(f'unexpected data: {string}')
        for t in self.tokens[:15]:
            print(t)
        breakpoint()
        pass

    def pop(self, what=None, expected=None):
        token, string = self.tokens[0]
        if what is not None and not str(token).startswith(str(what)):
            self.unexpected(string)
        if expected is not None and string.strip() != expected:
            self.unexpected(string)
        self.tokens.pop(0)
        return string

    def peek(self, position, ponctuation=None):
        token, string = self.tokens[position]
        # the self includes a last ' '
        if ponctuation and ponctuation != token:
            self.unexpected(string)
        return token, string.rstrip()

    def skip_keyword_block(self, name):
        count = 0
        while True:
            t, v = self.tokens.pop(0)
            if t != Token.Punctuation:
                continue
            if v.strip() == '{':
                count += 1
            if v.strip() == '}':
                count -= 1
            if not count:
                break

    def set_subtrees(self):
        """
        to make the core more redeable the tree[module] structure
        is presented as subtrees, this reset all the subtree
        for the current module
        """
        self.ns = self.tree[self.module]
        self.grouping = self.ns[yang.kw['grouping']]
        self.typedef = self.ns[yang.kw['typedef']]
        self.root = self.ns[yang.kw['root']]

    def imports(self, module, prefix):
        """
        load, and if missing and defined download, a yang module

        module: the name of the yang module to find
        prefix: how it is called (prefix)
        """
        fname = os.path.join(yang.folder, module) + '.yang'
        if not os.path.exists(fname):
            yang.fetch_model('models', module)

        backup = (self.tokens, self.module, self.prefix)
        self.load(prefix, fname)
        self.tokens, self.module, self.prefix = backup
        self.set_subtrees()

    def load(self, module, fname):
        """
        add a new yang module/namespace to the tree
        this function is used when initialising the
        root module, as it does not perform backups
        """
        self.tree.setdefault(yang.kw['loaded'], []).append(module)
        self.tokens = self.tokenise(fname)
        self.module = module
        self.prefix = module
        self.tree[module] = {
            yang.kw['typedef']: {},
            yang.kw['grouping']: {},
            yang.kw['root']: {},
        }
        self.set_subtrees()
        self.parse()

    def parse(self):
        self._parse([], self.root)
        return self.tree

    def _parse(self, inside, tree):
        while self.tokens:
            token, string = self.peek(0)

            if token == Token.Punctuation and string == '}':
                # it is clearer to pop it in the caller
                return

            self._parse_one(inside, tree, token, string)

    def _parse_one(self, inside, tree, token, string):
        if token == Token.Comment.Multiline:
            # ignore multiline comments
            self.pop(Token.Comment.Multiline)
            return

        if token == Token.Keyword.Namespace:
            self.pop(Token.Keyword.Namespace, 'module')
            self.pop(Token.Literal.String)
            self.pop(Token.Punctuation, '{')
            self._parse(inside, tree)
            self.pop(Token.Punctuation, '}')
            return

        if token != Token.Keyword or string not in yang.words:
            if ':' not in string:
                self.unknown(string, '')
                return

        self.pop(Token.Keyword, string)
        name = self.formated(self.pop(Token.Literal.String))

        if string == 'prefix':
            self.prefix = name
            self.pop(Token.Punctuation, ';')
            return

        if string in ('namespace', 'organization', 'contact', 'yang-version'):
            self.pop(Token.Punctuation, ';')
            return

        if string in ('revision', 'extension'):
            self.skip_keyword_block(Token.Punctuation)
            return

        if string in ('range', 'length'):
            self.pop(Token.Punctuation, ';')
            tree[yang.kw[string]] = [_ for _ in name.replace(' ', '').replace('..',' ').split()]
            return

        if string == 'import':
            token, string = self.peek(0, Token.Punctuation)
            if string == ';':
                self.pop(Token.Punctuation, ';')
                self.imports(name, name)
            if string == '{':
                self.pop(Token.Punctuation, '{')
                self.pop(Token.Keyword, 'prefix')
                prefix = self.formated(self.pop(Token.Literal.String))
                self.pop(Token.Punctuation, ';')
                self.pop(Token.Punctuation, '}')
                self.imports(name, prefix)
                return

        if string in ('description', 'reference'):
            self.pop(Token.Punctuation, ';')
            # XXX: not saved during debugging
            if DEBUG:
                return
            tree[yang.kw[string]] = name
            return

        if string in ('pattern', 'value', 'default', 'mandatory'):
            self.pop(Token.Punctuation, ';')
            tree[yang.kw[string]] = name
            return

        if string == 'key':
            self.pop(Token.Punctuation, ';')
            tree[yang.kw[string]] = name.split()
            return

        if string == 'typedef':
            self.pop(Token.Punctuation, '{')
            sub = self.typedef.setdefault(name, {})
            self._parse(inside + [name], sub)
            self.pop(Token.Punctuation, '}')
            return

        if string == 'enum':
            option = self.pop(Token.Punctuation)
            if option == ';':
                tree.setdefault(yang.kw[string], []).append(name)
                return
            if option == '{':
                sub = tree.setdefault(name, {})
                self._parse(inside + [name], sub)
                self.pop(Token.Punctuation, '}')
                return

        if string == 'type':
            option = self.pop(Token.Punctuation)
            if option == ';':
                if name in yang.types:
                    # not dealing with refine
                    tree.setdefault(yang.kw[string], name)
                    return

                if ':' not in name:
                    # a reference to a local type
                    # XXX: this need to be check post parsing
                    # yang allows to reference a type before its creation
                    # if name not in self.typedef:
                    #     self.unexpected(f'referenced a undefined local typedef {name}')

                    tree.setdefault(yang.kw[string], name)
                    return

                # a reference to a remote type
                # or the local namespace using a fully qualified name

                module, typeref = name.split(':', 1)

                if module == self.prefix:
                    module = self.module

                if module not in self.tree:
                    self.unexpected(f'referenced non-included module {name}')

                # yang allows to reference a type before its creation
                # XXX: this need to be check post parsing
                # if typeref not in self.tree[module][yang.kw['typedef']]:
                #     self.unexpected(f'referenced a undefined typedef {name}')

                tree.setdefault(yang.kw[string], name)
                return

            if option == '{':
                if name == 'union':
                    # sub = tree.setdefault(yang.kw[string], {}).setdefault(name, {})
                    # self._parse(inside + [name], sub)
                    # self.pop(Token.Punctuation, '}')
                    # continue

                    sub = tree.setdefault(yang.kw[string], {}).setdefault(name, [])
                    while True:
                        what, name = self.peek(0)
                        name = self.formated(name)
                        if name == 'type':
                            union_type = {}
                            self._parse_one(inside + [name], union_type, what, name)
                            sub.append(union_type[yang.kw['type']])
                            continue
                        if name == '}':
                            self.pop(Token.Punctuation, '}')
                            break
                        self.unexpected(f'did not expect this in an union: {what}')
                    return

                if name == 'enumeration':
                    sub = tree.setdefault(yang.kw[string], {}).setdefault(name, {})
                    self._parse(inside + [name], sub)
                    self.pop(Token.Punctuation, '}')
                    return

                if ':' in name or name in yang.types:
                    sub = tree.setdefault(yang.kw[string], {}).setdefault(name, {})
                    self._parse(inside + [name], sub)
                    self.pop(Token.Punctuation, '}')
                    return

        if string == 'uses':
            if name not in self.grouping:
                breakpoint()
            tree.update(self.grouping[name])
            option = self.pop(Token.Punctuation)
            if option == ';':
                return
            if option == '{':
                sub = tree.setdefault(name, {})
                self._parse(inside + [name], sub)
                self.pop(Token.Punctuation, '}')
                return

        if string == 'grouping':
            self.pop(Token.Punctuation, '{')
            sub = self.grouping.setdefault(name, {})
            self._parse(inside + [name], sub)
            self.pop(Token.Punctuation, '}')
            return

        if string in ('container', 'list', 'refine', 'leaf', 'leaf-list'):
            self.pop(Token.Punctuation, '{')
            sub = tree.setdefault(name, {})
            self._parse(inside + [name], sub)
            self.pop(Token.Punctuation, '}')
            return

        self.unknown(string, name)

    def unknown(self, string, name):
        # catch unknown keyword so we can implement them
        pprint.pprint(self.ns)
        pprint.pprint('\n')
        pprint.pprint(string)
        pprint.pprint(name)
        pprint.pprint('\n')
        for t in self.tokens[:15]:
            pprint.pprint(t)
        breakpoint()
        # good luck!
        pass


def save_dict(python, ns):
    print(f'generating {python}')
    with open(python, 'w') as w:
        w.write('# yang model converted to dict\n')
        w.write('\n')
        w.write('model = ')
        w.write(str(ns))
        w.write('\n')


# Used https://github.com/asottile/astpretty
# to understand how the python AST works
# Python 3.9 will have ast.unparse but until then
# https://github.com/simonpercivall/astunparse
# is used to generate code from the AST created

from ast import Module, FunctionDef, If, Return, BoolOp, BinOp, Add, Name, Param, Load, GtE, LtE, And, Or, UnaryOp, Call, Not, Attribute, Constant, Compare, USub, arguments, arg
import astunparse


def unique_name(prefix='function', counter=[0]):
    unique = counter.pop()
    unique += 1
    counter.append(unique)
    return f'{prefix}_{unique}'


def function(name, body):
    return [
        FunctionDef(
            name=name,
            args=arguments(
                posonlyargs=[],
                args=[arg(arg='value', annotation=None, type_comment=None)],
                vararg=None,
                kwonlyargs=[],
                kw_defaults=[],
                kwarg=None,
                defaults=[],
            ),
            body=body,
            decorator_list=[],
            returns=None,
            type_comment=None,
        )
    ]


def return_bool(value):
    return [
        Return(
            value=Constant(value=value, kind=None),
        )
    ]


def test_string(value):
    return [
        Return(
            value=Constant(value=True, kind=None),
        )
    ]


def test_digit():
    return [
        If(
            test=UnaryOp(
                op=Not(),
                operand=Call(
                    func=Attribute(
                        value=Name(id='value', ctx=Load()),
                        attr='isdigit',
                        ctx=Load(),
                    ),
                    args=[],
                    keywords=[],
                ),
            ),
            body=[
                Return(
                    value=Constant(value=False, kind=None),
                ),
            ],
            orelse=[],
        )
    ]


def test_lte(value):
    if value >= 0:
        comparators = [
            Constant(value=value, kind=None)
        ]
    else:
        comparators = [
            UnaryOp(
                op=USub(),
                operand=Constant(value=abs(value), kind=None),
            ),
        ]

    return [
        If(
            test=Compare(
                left=Call(
                    func=Name(id='int', ctx=Load()),
                    args=[Name(id='value', ctx=Load())],
                    keywords=[],
                ),
                ops=[LtE()],
                comparators=comparators,
                keywords=[],
            ),
            body=[
                Return(
                    value=Constant(value=False, kind=None),
                ),
            ],
            orelse=[],
        )
    ]


def test_gte(value):
    if value >= 0:
        comparators = [
            Constant(value=value, kind=None)
        ]
    else:
        comparators = [
            UnaryOp(
                op=USub(),
                operand=Constant(value=abs(value), kind=None),
            ),
        ]
    return [
        If(
            test=Compare(
                left=Call(
                    func=Name(id='int', ctx=Load()),
                    args=[Name(id='value', ctx=Load())],
                    keywords=[],
                ),
                ops=[GtE()],
                comparators=comparators,
            ),
            body=[
                Return(
                    value=Constant(value=False, kind=None),
                ),
            ],
            orelse=[],
        )
    ]


def test_range(minimum, maximum):
    return test_digit() + test_gte(minimum) + test_lte(maximum)


def test_union(tests):
    names = []
    body = []
    values = []

    for test in tests:
        func_name = unique_name('function')
        names.append(func_name)
        body += function(func_name, test + return_bool(True))

    for func_name in names:
        values += [
            UnaryOp(
                op=Not(),
                operand=Call(
                    func=Name(id=func_name, ctx=Load()),
                    args=[Name(id='value', ctx=Load())],
                    keywords=[],
                ),
            ),
        ]

    return body + [
        If(
            test=BoolOp(
                op=And(),
                values=values,
            ),
            body=[
                Return(
                    value=Constant(value=False, kind=None),
                ),
            ],
            orelse=[],
        ),
    ]


def gen_type(node):
    for keyword in node:
        # bodies is a list of list
        bodies = []
        if keyword == 'union':
            for union in node[keyword]:
                # this may not be required ?? always assume [type]?
                if union == yang.kw['type']:
                    for k, v in node[keyword][union].items():
                        sub = {k: v}
                        bodies.append(gen_type(sub))
                breakpoint()
                pass

            return test_union(bodies)

        if keyword in ('int8', 'int16', 'int16', 'int32', 'uint8', 'uint16', 'uint16', 'uint32'):
            # not dealing with refine
            minimum, maximum = yang.ranges[keyword]
            return test_range(minimum, maximum)

        if keyword == 'string':
            return test_string(node[keyword])
	
        # if keyword == 'string':
        #     gen_string(node[string])
        breakpoint()
        pass


def gen_check(node):
    print(node)

    body = []
    for keyword in node:
        if keyword == yang.kw['type']:
            body += gen_type(node[keyword])

    return body + return_bool(True)


def main():
    folder = os.path.dirname(__file__)
    os.chdir(os.path.abspath(folder))

    yang.load('yang-library-data.json', 'models')
    ns = Lexer('exabgp.yang').parse()

    # save_dict('model.py', root)
    pprint.pprint(ns)
    return

    body = gen_check(ns[yang.kw['typedef']]['bgp-std-community-type'])
    ast = Module(
        body=body,
    )
    code = astunparse.unparse(ast)
    print(code)


if __name__ == "__main__":
    main()
