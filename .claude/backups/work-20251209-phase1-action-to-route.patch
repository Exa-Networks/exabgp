diff --git a/TODO b/TODO
index c138409f5..a5c2f652e 100644
--- a/TODO
+++ b/TODO
@@ -1,2 +1,17 @@
-convert FSM to use IntEnum 
-convert code to use async
+Fix resolve_self() deepcopy by creation of copy
+remove hierarchy of NLRI from IPBase and use interface ?
+remove action from NLRI and have it passed along
+RIB interning
+
+Ask Claude if we duplicate the storage of PathInfo in some NLRI
+
+
+  | Phase | Optimization                | Savings  | Complexity |
+  |-------|-----------------------------|----------|------------|
+  | 1     | Fix resolve_self() deepcopy | 60-80%   | Low        |
+  | 2     | NLRI interning pool         | 20-40%   | Medium     |
+  | 3     | Attribute interning         | 30-50%   | Medium     |
+  | 4     | NextHop interning           | 10-20%   | Low        |
+  | 5     | Reference-based RIB         | Variable | High       |
+  
+
diff --git a/plan/nexthop-self-refactor.md b/plan/nexthop-self-refactor.md
deleted file mode 100644
index 4a3e1d625..000000000
--- a/plan/nexthop-self-refactor.md
+++ /dev/null
@@ -1,468 +0,0 @@
-# NextHopSelf Refactoring Plan
-
-**Status:** ✅ Phase 3 Complete (Mutate-in-place)
-**Created:** 2025-12-08
-**Updated:** 2025-12-08
-
----
-
-## Executive Summary
-
-`NextHopSelf` is a sentinel pattern that defers next-hop IP resolution until neighbor session context is known. Currently, resolution happens at **two points**:
-1. **Configuration load time** via `neighbor.remove_self()` - PRIMARY (replaces sentinel permanently)
-2. **Pack time** via `nlri.nexthop.ton(negotiated)` - SAFETY NET (if sentinel survives to packing)
-
-The current design couples UPDATE parsing to neighbor session state (`Negotiated.neighbor`), preventing `Update` from using lightweight `OpenContext`.
-
----
-
-## Current Architecture
-
-### Class Hierarchy
-
-```
-NextHop (Attribute)
-├── SELF: ClassVar[bool] = False
-├── _packed: Buffer  # Wire-format IP bytes
-├── ton() → self._packed
-└── pack_attribute(negotiated) → self._attribute(self._packed)
-
-NextHopSelf(NextHop)
-├── SELF: ClassVar[bool] = True
-├── _afi: AFI  # Address family (no packed bytes yet)
-├── _packed = b''  # Empty placeholder
-├── ton(negotiated, afi) → negotiated.nexthopself(afi).ton()
-└── pack_attribute(negotiated) → self._attribute(negotiated.nexthopself(self._afi).ton())
-
-IPSelf
-├── SELF: ClassVar[bool] = True
-├── afi: AFI
-├── ton(negotiated, afi) → negotiated.nexthopself(afi).ton()
-└── pack(negotiated) → negotiated.nexthopself(self.afi).ton()
-
-IP
-├── SELF: ClassVar[bool] = False
-├── _packed: Buffer
-└── ton() → self._packed
-```
-
-### Key Files
-
-| File | Purpose |
-|------|---------|
-| `src/exabgp/bgp/message/update/attribute/nexthop.py:136-173` | `NextHopSelf` class definition |
-| `src/exabgp/protocol/ip/__init__.py:29-50` | `IPSelf` class definition |
-| `src/exabgp/bgp/neighbor/neighbor.py:281-289` | `remove_self()` - primary resolution |
-| `src/exabgp/bgp/neighbor/session.py:105-127` | `ip_self()` - actual IP lookup |
-| `src/exabgp/bgp/message/open/capability/negotiated.py:314-315` | `nexthopself()` - delegate to neighbor |
-
-### Configuration Parsing (Sentinel Creation)
-
-All parsers detect literal string `"self"` and create sentinels:
-
-| Parser | File:Line | Creates |
-|--------|-----------|---------|
-| Static routes | `configuration/static/parser.py:88-95` | `IPSelf(afi), NextHopSelf(afi)` |
-| Flow routes | `configuration/flow/parser.py:298-304` | `NextHopSelf(AFI.ipv4)` |
-| L2VPN routes | `configuration/l2vpn/parser.py:51-56` | `NextHopSelf(AFI.ipv4)` |
-| Validator | `configuration/validator.py:745-760` | `IPSelf(afi), NextHopSelf(afi)` |
-
-### NLRI Nexthop Assignment
-
-After parsing, nexthop (possibly `NextHopSelf`) is assigned to NLRI:
-
-| File:Line | Context |
-|-----------|---------|
-| `configuration/static/route.py:511` | `new_nlri.nexthop = nexthop` |
-| `configuration/announce/__init__.py:87` | `nlri.nexthop = nexthop` |
-
-### Resolution Flow (Current)
-
-```
-Configuration File: "next-hop self"
-         ↓
-Parser: Creates NextHopSelf(AFI) sentinel
-         ↓
-Route.nlri.nexthop = NextHopSelf (SENTINEL STORED)
-         ↓
-neighbor.remove_self(route) called at config load time
-         ↓
-Checks: route.nlri.nexthop.SELF == True?
-    ├── Yes → neighbor.ip_self(afi) → session.ip_self(afi)
-    │         Returns: local_address or router_id
-    │         Replaces: nlri.nexthop = resolved IP (permanent)
-    │         Also: attributes[NEXT_HOP] = NextHop(resolved_ip)
-    └── No  → Return route unchanged
-         ↓
-Route added to RIB (with resolved nexthop)
-         ↓
-Pack time: nlri.nexthop.ton(negotiated, afi)
-    ├── IP.ton() → self._packed (already resolved)
-    └── IPSelf.ton() → negotiated.nexthopself(afi).ton() (safety net)
-```
-
-### Call Sites for `remove_self()`
-
-```python
-# configuration/neighbor/__init__.py
-neighbor.routes.append(neighbor.remove_self(route))  # Lines 442, 450, 456
-route = neighbor.remove_self(route)                   # Line 462
-
-# configuration/configuration.py
-neighbor.rib.outgoing.add_to_rib(neighbor.remove_self(route))  # Line 79
-```
-
-### IP Resolution Logic (`session.ip_self()`)
-
-```python
-def ip_self(self, afi: AFI) -> IP:
-    # Case 1: AFI matches local_address
-    if not self.auto_discovery and afi == self.local_address.afi:
-        return self.local_address
-
-    # Case 2: IPv4 route with IPv6 session - use router_id
-    if afi == AFI.ipv4 and self.router_id is not None:
-        return self.router_id
-
-    # Case 3: Cannot resolve - error
-    raise TypeError('AFI mismatch...')
-```
-
----
-
-## Problem Statement
-
-### Why This Matters for Wire-Semantic Separation
-
-The `Update` class currently stores `Negotiated` because:
-1. `Update.parse()` needs `negotiated.families` to filter NLRIs
-2. `Update.parse()` needs `negotiated.neighbor` for next-hop-self resolution
-
-If next-hop-self were resolved at NLRI **creation time** (not parsing time), `Update` could store lightweight `OpenContext` instead.
-
-### Current Coupling
-
-```
-Update._negotiated: Negotiated
-     │
-     ├── families: list[tuple[AFI, SAFI]]  # Needed for NLRI filtering
-     ├── neighbor: Neighbor                 # Needed for nexthopself()
-     │       └── session.ip_self(afi)      # Resolves "self" to IP
-     └── required(afi, safi): bool         # Needed for AddPath
-```
-
-### Desired State
-
-```
-Update._context: OpenContext  # Lightweight, no neighbor reference
-     │
-     ├── afi, safi, addpath, asn4, msg_size
-     └── local_as, peer_as, is_ibgp
-
-NLRI.nexthop: IP  # Always concrete, never sentinel
-```
-
----
-
-## Design Options
-
-### Option A: Resolve at NLRI Creation Time (Early Resolution)
-
-**Approach:** Pass resolved IP to NLRI constructor, never store sentinel.
-
-**Pros:**
-- Cleanest separation - NLRIs are always concrete
-- `Update` can use `OpenContext`
-- No sentinel classes needed
-
-**Cons:**
-- Requires IP at config parse time (neighbor session may not exist)
-- Breaks deferred resolution pattern
-- API change for all NLRI constructors
-
-**Feasibility:** LOW - neighbor session doesn't exist at config parse time.
-
-### Option B: Resolve at RIB Insertion (Current Pattern, Formalized)
-
-**Approach:** Keep current `remove_self()` pattern but:
-1. Make it explicit that RIB insertion is the resolution boundary
-2. Assert NLRIs in RIB never have `SELF=True`
-3. Remove pack-time safety net (fail fast if sentinel escapes)
-
-**Pros:**
-- Minimal code change
-- Clear boundary (RIB = concrete data)
-- Validates current invariant
-
-**Cons:**
-- Doesn't help `Update` use `OpenContext`
-- Still need sentinel classes
-
-**Feasibility:** HIGH - formalize existing behavior.
-
-### Option C: Store Local IP in OpenContext
-
-**Approach:** Add `local_ip: IP` field to `OpenContext`.
-
-```python
-class OpenContext:
-    __slots__ = ('afi', 'safi', 'addpath', 'asn4', 'msg_size',
-                 'local_as', 'peer_as', 'local_ip')
-```
-
-**Pros:**
-- NLRIs can resolve nexthop via context
-- `Update` can use `OpenContext`
-- Single source of truth
-
-**Cons:**
-- `OpenContext` grows (but still lightweight)
-- Caching key changes (adds IP to tuple)
-- Chicken-and-egg: may not know local_ip at parse time
-
-**Feasibility:** MEDIUM - depends on when local_ip is known.
-
-### Option D: Two-Phase Parsing (Parse → Resolve)
-
-**Approach:**
-1. Parse UPDATE into structure with unresolved nexthops
-2. Resolve nexthops in a second pass when session context available
-
-```python
-class Update:
-    _context: OpenContext
-    _needs_resolution: bool  # True if any nexthop is sentinel
-
-def resolve_nexthops(self, neighbor: Neighbor) -> None:
-    """Second pass: resolve any NextHopSelf sentinels."""
-    for nlri in self.nlris:
-        if nlri.nexthop.SELF:
-            nlri.nexthop = neighbor.ip_self(nlri.afi)
-```
-
-**Pros:**
-- Clear separation of parsing and resolution
-- `Update` can use `OpenContext` for parsing
-- Explicit about resolution requirement
-
-**Cons:**
-- Two-phase API more complex
-- Callers must remember to call resolve
-- Still need sentinel during transition
-
-**Feasibility:** MEDIUM - cleaner but more complex.
-
-### Option E: Resolve in `pack()` Only (Remove `remove_self()`)
-
-**Approach:** Remove config-time resolution, always resolve at pack time.
-
-**Pros:**
-- Single resolution point
-- Simplifies config loading
-
-**Cons:**
-- Sentinel persists longer (through RIB)
-- Need `Negotiated` for packing (can't use `OpenContext`)
-- Breaks current invariant
-
-**Feasibility:** LOW - makes wire-semantic separation harder.
-
----
-
-## Recommended Approach
-
-**Option B (Formalize Current Pattern)** as Phase 1, **Option D (Two-Phase)** as Phase 2.
-
-### Phase 1: Formalize Current Behavior
-
-1. Add assertion that NLRIs in RIB never have `nexthop.SELF == True`
-2. Document that `remove_self()` is the resolution boundary
-3. Consider removing pack-time resolution (fail if sentinel escapes)
-
-### Phase 2: Two-Phase Parsing (Future)
-
-1. `Update.parse()` accepts `OpenContext` (no neighbor)
-2. New method `Update.resolve_nexthops(neighbor)` resolves sentinels
-3. Wire containers (`Update`) hold unresolved data
-4. Semantic containers (`UpdateCollection`) hold resolved data
-
----
-
-## Detailed Analysis
-
-### When is Neighbor Session Available?
-
-| Context | Session Available? | Can Resolve? |
-|---------|-------------------|--------------|
-| Config file parsing | No | No |
-| `neighbor { }` block exit | Yes (Neighbor created) | Yes |
-| Route added to neighbor.routes | Yes | Yes (current) |
-| Route added to RIB | Yes | Yes (current) |
-| UPDATE received from wire | Yes (established session) | Yes |
-| UPDATE packed for sending | Yes | Yes (pack-time fallback) |
-
-**Key insight:** Resolution can happen earliest at neighbor block exit.
-
-### What Needs `nexthopself()` at Parse Time?
-
-Currently: Nothing. Parse creates sentinel, resolution happens later.
-
-The coupling is via `Negotiated.nexthopself()` which delegates to `neighbor.ip_self()`.
-
-### What Actually Uses `Negotiated.neighbor` During Parsing?
-
-```python
-# collection.py:406-420 - NEXT_HOP validation
-neighbor = getattr(negotiated, 'neighbor', None)
-if nexthop is not IP.NoNextHop and neighbor is not None:
-    local_address = neighbor.session.local_address
-    if nexthop_packed == local_packed:
-        log.warning('received NEXT_HOP equals our local address...')
-```
-
-This is a **validation** (RFC 4271 compliance check), not resolution. Could be deferred.
-
----
-
-## Test Coverage
-
-### Existing Tests
-
-| Test | File | Coverage |
-|------|------|----------|
-| NextHopSelf unit tests | `tests/unit/test_path_attributes.py:882-897` | Basic construction |
-
-### Tests Needed
-
-- [ ] `remove_self()` replaces sentinel with concrete IP
-- [ ] Sentinel never reaches RIB
-- [ ] Pack-time resolution works as fallback
-- [ ] AFI mismatch raises TypeError
-- [ ] Router-id fallback for IPv4 routes with IPv6 session
-
----
-
-## Implementation Plan
-
-### Phase 1: Formalize & Document (Low Risk) ✅ COMPLETE
-
-**Goal:** Make current behavior explicit with no functional changes.
-
-1. **Add RIB entry assertion** ✅
-   - In `rib.outgoing._update_rib()`, assert `nlri.nexthop.SELF == False`
-   - Fast-fail if sentinel escapes to RIB
-   - File: `src/exabgp/rib/outgoing.py:310-315`
-
-2. **Add tests** ✅
-   - Test `remove_self()` behavior
-   - Test AFI resolution paths
-   - Test sentinel detection
-   - Test RIB rejection of unresolved sentinels
-   - File: `tests/unit/test_nexthop_self.py` (26 tests)
-
-3. **Document invariant** ✅
-   - NLRIs in RIB always have concrete nexthop
-   - `remove_self()` is the resolution boundary
-   - Pack-time resolution is safety net (never triggered in practice)
-
-### Phase 2: Remove Pack-Time Resolution ✅ COMPLETE
-
-**Goal:** Remove redundant pack-time resolution - convert to errors.
-
-1. **Verify sentinel never escapes** ✅
-   - Phase 1 RIB assertion proves sentinels never reach pack time
-   - All 11 test suites pass with assertion
-
-2. **Convert pack-time resolution to errors** ✅
-   - `NextHopSelf.pack_attribute()` → raises `RuntimeError`
-   - `NextHopSelf.ton()` → raises `RuntimeError`
-   - `IPSelf.top()` → raises `RuntimeError`
-   - `IPSelf.ton()` → raises `RuntimeError`
-   - `IPSelf.pack()` → raises `RuntimeError`
-   - Files modified:
-     - `src/exabgp/bgp/message/update/attribute/nexthop.py:165-179`
-     - `src/exabgp/protocol/ip/__init__.py:39-61`
-
-3. **Add tests for raise behavior** ✅
-   - `test_pack_attribute_raises` - NextHopSelf
-   - `test_ton_raises` - NextHopSelf
-   - `test_top_raises` - IPSelf
-   - `test_ton_raises` - IPSelf
-   - `test_pack_raises` - IPSelf
-   - File: `tests/unit/test_nexthop_self.py` (now 31 tests)
-
-### Phase 3: Mutate-in-place Resolution ✅ COMPLETE
-
-**Goal:** Change `resolve_self()` to mutate sentinels in-place instead of replacing.
-
-**Design:**
-- `SELF` stays as ClassVar (always True for sentinel classes)
-- Resolution state detected via `_packed == b''` (unresolved) vs non-empty (resolved)
-- Added `resolved` property and `resolve()` method
-
-**Changes:**
-
-1. **IPSelf (`src/exabgp/protocol/ip/__init__.py:37-76`)**
-   - Added `_packed: Buffer` attribute
-   - Added `resolved` property
-   - Added `resolve(ip)` method
-   - Added `ton()`, `pack_ip()` methods that raise if not resolved
-   - Updated `__repr__()` and `index()` to handle resolved state
-
-2. **NextHopSelf (`src/exabgp/bgp/message/update/attribute/nexthop.py:136-184`)**
-   - Added `resolved` property
-   - Added `resolve(ip)` method
-   - Updated `pack_attribute()` to raise if not resolved
-   - Updated `__repr__()` to handle resolved state
-
-3. **resolve_self() (`src/exabgp/bgp/neighbor/neighbor.py:281-303`)**
-   - Changed to call `nexthop.resolve(neighbor_self)` instead of replacing
-   - Checks `nexthop.resolved` to skip already-resolved sentinels
-
-4. **RIB assertion (`src/exabgp/rib/outgoing.py:309-316`)**
-   - Changed to check `SELF and not resolved` (allows resolved sentinels)
-
-5. **Tests (`tests/unit/test_nexthop_self.py`)**
-   - Updated all tests for new behavior
-   - Tests verify SELF stays True after resolution
-   - Tests verify resolved transitions to True
-
-**Key Invariants:**
-- Before: `SELF=True`, `_packed=b''`, `resolved=False`
-- After: `SELF=True`, `_packed=bytes`, `resolved=True`
-- Pack methods raise `ValueError` if `not resolved`
-
-### Phase 4: Two-Phase Parsing (Future)
-
-**Goal:** Enable `Update` to use `OpenContext`.
-
-1. **Add `Update.resolve_nexthops(neighbor)`**
-2. **Change callers to call resolution explicitly**
-3. **Change `Update._negotiated` to `Update._context`**
-
----
-
-## Dependencies
-
-- Wire-Semantic Separation plan (completed phases 1-3)
-- OpenContext has `local_as`, `peer_as` (completed)
-
----
-
-## Questions to Resolve
-
-1. **Is pack-time resolution ever triggered?**
-   - If yes, where?
-   - If no, can we remove it?
-
-2. **Should `Update` store sentinel or resolved IP?**
-   - Wire container: Could store sentinel (raw wire + context)
-   - Semantic container: Should store resolved IP
-
-3. **Can NEXT_HOP validation be deferred?**
-   - Currently in `_parse_payload()`, needs `neighbor.session.local_address`
-   - Could move to post-parse validation phase
-
----
-
-**Updated:** 2025-12-08
diff --git a/src/exabgp/configuration/announce/ip.py b/src/exabgp/configuration/announce/ip.py
index b24a48544..6f9a34d57 100644
--- a/src/exabgp/configuration/announce/ip.py
+++ b/src/exabgp/configuration/announce/ip.py
@@ -156,7 +156,7 @@ class AnnounceIP(ParseAnnounce):
     @staticmethod
     def check(route: Route, afi: AFI | None) -> bool:
         if (
-            route.nlri.action == Action.ANNOUNCE
+            route.action == Action.ANNOUNCE
             and route.nlri.nexthop is IP.NoNextHop
             and route.nlri.afi == afi
             and route.nlri.safi in (SAFI.unicast, SAFI.multicast)
diff --git a/src/exabgp/configuration/announce/label.py b/src/exabgp/configuration/announce/label.py
index d0b376e54..d81a47d3e 100644
--- a/src/exabgp/configuration/announce/label.py
+++ b/src/exabgp/configuration/announce/label.py
@@ -76,7 +76,7 @@ class AnnounceLabel(AnnouncePath):
             return False
 
         # has_label() confirms the NLRI type has a labels attribute
-        if route.nlri.action == Action.ANNOUNCE and route.nlri.has_label():
+        if route.action == Action.ANNOUNCE and route.nlri.has_label():
             if cast(Label, route.nlri).labels is Labels.NOLABEL:
                 return False
 
diff --git a/src/exabgp/configuration/announce/vpn.py b/src/exabgp/configuration/announce/vpn.py
index 52475b347..cc00d3247 100644
--- a/src/exabgp/configuration/announce/vpn.py
+++ b/src/exabgp/configuration/announce/vpn.py
@@ -76,7 +76,7 @@ class AnnounceVPN(ParseAnnounce):
             return False
 
         # has_rd() confirms the NLRI type has an rd attribute
-        if route.nlri.action == Action.ANNOUNCE and route.nlri.has_rd():
+        if route.action == Action.ANNOUNCE and route.nlri.has_rd():
             if cast(IPVPN, route.nlri).rd is RouteDistinguisher.NORD:
                 return False
 
diff --git a/src/exabgp/configuration/check.py b/src/exabgp/configuration/check.py
index 5c32e896a..4b1cba2d5 100644
--- a/src/exabgp/configuration/check.py
+++ b/src/exabgp/configuration/check.py
@@ -465,7 +465,7 @@ def check_update(neighbor: Neighbor, raw: bytes) -> bool:
         log.info(
             lazymsg(
                 'update.decoded action={action} extensive={extensive}',
-                action=_route.nlri.action,
+                action=_route.action,
                 extensive=_route.extensive(),
             ),
             'parser',
diff --git a/src/exabgp/configuration/l2vpn/vpls.py b/src/exabgp/configuration/l2vpn/vpls.py
index 02c1359ea..79e2aab2b 100644
--- a/src/exabgp/configuration/l2vpn/vpls.py
+++ b/src/exabgp/configuration/l2vpn/vpls.py
@@ -11,6 +11,7 @@ from exabgp.configuration.core import Section
 from exabgp.configuration.schema import RouteBuilder, Leaf, LeafList, ValueType
 from exabgp.configuration.validator import LegacyParserValidator
 
+from exabgp.bgp.message import Action
 from exabgp.bgp.message.update.nlri import VPLS as VPLS_NLRI
 from exabgp.bgp.message.update.nlri.settings import VPLSSettings
 
@@ -302,7 +303,7 @@ class ParseVPLS(Section):
 
         # Create NLRI from settings (no mutation after this point)
         nlri = VPLS_NLRI.from_settings(settings)
-        route = Route(nlri, attributes)
+        route = Route(nlri, attributes, Action.ANNOUNCE)
 
         # Append route and clear settings
         self.scope.append_route(route)
diff --git a/src/exabgp/configuration/neighbor/__init__.py b/src/exabgp/configuration/neighbor/__init__.py
index 170d43f5b..33eeb50d2 100644
--- a/src/exabgp/configuration/neighbor/__init__.py
+++ b/src/exabgp/configuration/neighbor/__init__.py
@@ -445,13 +445,13 @@ class ParseNeighbor(Section):
         for section in ('static', 'l2vpn', 'flow'):
             routes = local.get(section, {}).get('routes', [])
             for route in routes:
-                route.nlri.action = Action.ANNOUNCE
+                route.action = Action.ANNOUNCE
                 # remove_self may well have side effects on route
                 neighbor.routes.append(neighbor.resolve_self(route))
 
         routes = local.get('routes', [])
         for route in routes:
-            route.nlri.action = Action.ANNOUNCE
+            route.action = Action.ANNOUNCE
             # remove_self may well have side effects on route
             neighbor.routes.append(neighbor.resolve_self(route))
 
diff --git a/src/exabgp/configuration/validator.py b/src/exabgp/configuration/validator.py
index 25a9a59d2..2ea1769d5 100644
--- a/src/exabgp/configuration/validator.py
+++ b/src/exabgp/configuration/validator.py
@@ -19,6 +19,8 @@ from copy import deepcopy
 from dataclasses import dataclass, field
 from typing import TYPE_CHECKING, Any, Callable, Generic, TypeVar
 
+from exabgp.bgp.message import Action
+
 if TYPE_CHECKING:
     from exabgp.bgp.message.open.asn import ASN
     from exabgp.bgp.message.update.attribute import MED, LocalPreference, NextHop, NextHopSelf, Origin
@@ -1138,7 +1140,7 @@ class RouteBuilderValidator(Validator[list[Any]]):
         # Create immutable NLRI from validated settings
         nlri = self.schema.nlri_class.from_settings(settings)
 
-        return [Route(nlri, attributes)]
+        return [Route(nlri, attributes, Action.ANNOUNCE)]
 
     def _apply_settings_action(self, settings: Any, attributes: Any, command: str, action: str, value: Any) -> None:
         """Apply parsed value to Settings object based on action."""
@@ -1235,10 +1237,10 @@ class TypeSelectorValidator(Validator[list[Any]]):
         else:
             nlri = factory(tokeniser, self.afi)
 
-        # Set action after factory (action defaults to UNSET, must be set)
+        # Set action on Route (nlri.action set for backward compat, will be removed)
         nlri.action = self.action_type
 
-        route = Route(nlri, AttributeCollection())
+        route = Route(nlri, AttributeCollection(), self.action_type)
 
         # Process remaining tokens as attributes
         from exabgp.configuration.schema import Leaf, LeafList
diff --git a/src/exabgp/reactor/api/command/announce.py b/src/exabgp/reactor/api/command/announce.py
index e1bc95457..0a5341b08 100644
--- a/src/exabgp/reactor/api/command/announce.py
+++ b/src/exabgp/reactor/api/command/announce.py
@@ -112,7 +112,7 @@ def announce_route(
                     peer_list = ', '.join(peers) if peers else 'all peers'
                     self.log_message(f'invalid route for {peer_list} : {route.extensive()}')
                     continue
-                route.nlri.action = Action.ANNOUNCE
+                route.action = Action.ANNOUNCE
                 reactor.configuration.inject_route(peers, route)
                 peer_list = ', '.join(peers) if peers else 'all peers'
                 self.log_message(f'route added to {peer_list} : {route.extensive()}')
@@ -160,7 +160,7 @@ def withdraw_route(
 
             for route in routes:
                 # Set the action to withdraw before checking the route
-                route.nlri.action = Action.WITHDRAW
+                route.action = Action.WITHDRAW
                 # NextHop is a mandatory field (but we do not require in)
                 if route.nlri.nexthop is IP.NoNextHop:
                     route.nlri.nexthop = NextHop.from_string('0.0.0.0')
@@ -217,7 +217,7 @@ def announce_vpls(
             flush_events = register_flush_callbacks(peers, reactor, sync_mode)
 
             for route in routes:
-                route.nlri.action = Action.ANNOUNCE
+                route.action = Action.ANNOUNCE
                 reactor.configuration.inject_route(peers, route)
                 peer_list = ', '.join(peers) if peers else 'all peers'
                 self.log_message(f'vpls added to {peer_list} : {route.extensive()}')
@@ -258,7 +258,7 @@ def withdraw_vpls(
             flush_events = register_flush_callbacks(peers, reactor, sync_mode)
 
             for route in routes:
-                route.nlri.action = Action.WITHDRAW
+                route.action = Action.WITHDRAW
                 if reactor.configuration.inject_route(peers, route):
                     peer_list = ', '.join(peers) if peers else 'all peers'
                     self.log_message(f'vpls removed from {peer_list} : {route.extensive()}')
@@ -301,7 +301,7 @@ def announce_attributes(
             flush_events = register_flush_callbacks(peers, reactor, sync_mode)
 
             for route in routes:
-                route.nlri.action = Action.ANNOUNCE
+                route.action = Action.ANNOUNCE
                 reactor.configuration.inject_route(peers, route)
                 peer_list = ', '.join(peers) if peers else 'all peers'
                 self.log_message(f'route added to {peer_list} : {route.extensive()}')
@@ -347,7 +347,7 @@ def withdraw_attribute(
             flush_events = register_flush_callbacks(peers, reactor, sync_mode)
 
             for route in routes:
-                route.nlri.action = Action.WITHDRAW
+                route.action = Action.WITHDRAW
                 if reactor.configuration.inject_route(peers, route):
                     peer_list = ', '.join(peers) if peers else 'all peers'
                     self.log_message(f'route removed from {peer_list} : {route.extensive()}')
@@ -397,7 +397,7 @@ def announce_flow(
             flush_events = register_flush_callbacks(peers, reactor, sync_mode)
 
             for route in routes:
-                route.nlri.action = Action.ANNOUNCE
+                route.action = Action.ANNOUNCE
                 reactor.configuration.inject_route(peers, route)
                 peer_list = ', '.join(peers) if peers else 'all peers'
                 self.log_message(f'flow added to {peer_list} : {route.extensive()}')
@@ -438,7 +438,7 @@ def withdraw_flow(
             flush_events = register_flush_callbacks(peers, reactor, sync_mode)
 
             for route in routes:
-                route.nlri.action = Action.WITHDRAW
+                route.action = Action.WITHDRAW
                 if reactor.configuration.inject_route(peers, route):
                     peer_list = ', '.join(peers) if peers else 'all peers'
                     self.log_message(f'flow removed from {peer_list} : {route.extensive()}')
@@ -606,7 +606,7 @@ def announce_ipv4(
             flush_events = register_flush_callbacks(peers, reactor, sync_mode)
 
             for route in routes:
-                route.nlri.action = Action.ANNOUNCE
+                route.action = Action.ANNOUNCE
                 reactor.configuration.inject_route(peers, route)
                 peer_list = ', '.join(peers) if peers else 'all peers'
                 self.log_message(f'ipv4 added to {peer_list} : {route.extensive()}')
@@ -647,7 +647,7 @@ def withdraw_ipv4(
             flush_events = register_flush_callbacks(peers, reactor, sync_mode)
 
             for route in routes:
-                route.nlri.action = Action.WITHDRAW
+                route.action = Action.WITHDRAW
                 if reactor.configuration.inject_route(peers, route):
                     peer_list = ', '.join(peers) if peers else 'all peers'
                     self.log_message(f'ipv4 removed from {peer_list} : {route.extensive()}')
@@ -690,7 +690,7 @@ def announce_ipv6(
             flush_events = register_flush_callbacks(peers, reactor, sync_mode)
 
             for route in routes:
-                route.nlri.action = Action.ANNOUNCE
+                route.action = Action.ANNOUNCE
                 reactor.configuration.inject_route(peers, route)
                 peer_list = ', '.join(peers) if peers else 'all peers'
                 self.log_message(f'ipv6 added to {peer_list} : {route.extensive()}')
@@ -731,7 +731,7 @@ def withdraw_ipv6(
             flush_events = register_flush_callbacks(peers, reactor, sync_mode)
 
             for route in routes:
-                route.nlri.action = Action.WITHDRAW
+                route.action = Action.WITHDRAW
                 if reactor.configuration.inject_route(peers, route):
                     peer_list = ', '.join(peers) if peers else 'all peers'
                     self.log_message(f'ipv6 removed from {peer_list} : {route.extensive()}')
diff --git a/src/exabgp/rib/cache.py b/src/exabgp/rib/cache.py
index 3b4815726..bfa295217 100644
--- a/src/exabgp/rib/cache.py
+++ b/src/exabgp/rib/cache.py
@@ -67,9 +67,9 @@ class Cache:
             return False
 
         # Withdraws are never duplicates - they always need to be processed
-        if route.nlri.action == Action.UNSET:
-            raise RuntimeError(f'NLRI action is UNSET (not set to ANNOUNCE or WITHDRAW): {route.nlri}')
-        if route.nlri.action == Action.WITHDRAW:
+        if route.action == Action.UNSET:
+            raise RuntimeError(f'Route action is UNSET (not set to ANNOUNCE or WITHDRAW): {route.nlri}')
+        if route.action == Action.WITHDRAW:
             return False
 
         cached = self._seen.get(route.nlri.family().afi_safi(), {}).get(route.index(), None)
@@ -111,14 +111,14 @@ class Cache:
 
         # Handle signatures: (route) or (nlri, attributes) or (nlri, attributes, action)
         if attributes is None:
-            # Legacy signature: update_cache(route) - uses nlri.action
+            # Legacy signature: update_cache(route) - uses route.action
             route = route_or_nlri
             nlri = route.nlri
             attrs = route.attributes
             family = nlri.family().afi_safi()
             index = route.index()
-            # For legacy callers, still read from nlri.action
-            actual_action = nlri.action
+            # Use route.action (which falls back to nlri.action during transition)
+            actual_action = route.action
         else:
             # New signature: update_cache(nlri, attributes[, action])
             nlri = route_or_nlri
diff --git a/src/exabgp/rib/outgoing.py b/src/exabgp/rib/outgoing.py
index 84b1d18f7..9f6658852 100644
--- a/src/exabgp/rib/outgoing.py
+++ b/src/exabgp/rib/outgoing.py
@@ -203,7 +203,7 @@ class OutgoingRIB(Cache):
             return
         if watchdog in self._watchdog:
             for route in list(self._watchdog[watchdog].get('-', {}).values()):
-                route.nlri.action = Action.ANNOUNCE  # pylint: disable=E1101
+                route.action = Action.ANNOUNCE
                 self.add_to_rib(route)
                 self._watchdog[watchdog].setdefault('+', {})[route.index()] = route
                 self._watchdog[watchdog]['-'].pop(route.index())
@@ -366,12 +366,12 @@ class OutgoingRIB(Cache):
 
                 attributes = new_attr[attr_index]
 
-                # Validate and separate announces and withdraws based on nlri.action
+                # Validate and separate announces and withdraws based on route.action
                 for route in routes.values():
-                    if route.nlri.action == Action.UNSET:
-                        raise RuntimeError(f'NLRI action is UNSET (not set to ANNOUNCE or WITHDRAW): {route.nlri}')
-                announces = [route.nlri for route in routes.values() if route.nlri.action == Action.ANNOUNCE]
-                withdraws = [route.nlri for route in routes.values() if route.nlri.action == Action.WITHDRAW]
+                    if route.action == Action.UNSET:
+                        raise RuntimeError(f'Route action is UNSET (not set to ANNOUNCE or WITHDRAW): {route.nlri}')
+                announces = [route.nlri for route in routes.values() if route.action == Action.ANNOUNCE]
+                withdraws = [route.nlri for route in routes.values() if route.action == Action.WITHDRAW]
 
                 if family == (AFI.ipv4, SAFI.unicast) and grouped:
                     if announces:
@@ -395,9 +395,9 @@ class OutgoingRIB(Cache):
 
                 # Non-grouped: one Update per NLRI
                 for route in routes.values():
-                    if route.nlri.action == Action.UNSET:
-                        raise RuntimeError(f'NLRI action is UNSET (not set to ANNOUNCE or WITHDRAW): {route.nlri}')
-                    if route.nlri.action == Action.WITHDRAW:
+                    if route.action == Action.UNSET:
+                        raise RuntimeError(f'Route action is UNSET (not set to ANNOUNCE or WITHDRAW): {route.nlri}')
+                    if route.action == Action.WITHDRAW:
                         yield UpdateCollection([], [route.nlri], attributes)
                     else:
                         yield UpdateCollection([route.nlri], [], attributes)
diff --git a/src/exabgp/rib/route.py b/src/exabgp/rib/route.py
index 28cb176bd..2e0123ef8 100644
--- a/src/exabgp/rib/route.py
+++ b/src/exabgp/rib/route.py
@@ -14,27 +14,58 @@ if TYPE_CHECKING:
     from exabgp.bgp.message.update.nlri.nlri import NLRI
     from exabgp.protocol.family import AFI, SAFI
 
+from exabgp.bgp.message import Action
+
 
 class Route:
-    __slots__ = ('nlri', 'attributes', '_Route__index')
+    """A Route is an NLRI with attributes and operation context.
+
+    The action field indicates whether this route is being announced or withdrawn.
+    This is operation context, not part of the NLRI identity - the same NLRI can
+    be announced and later withdrawn.
+
+    During the transition period, action falls back to nlri.action if not set.
+    Eventually, action will only be stored in Route, not in NLRI.
+    """
+
+    __slots__ = ('nlri', 'attributes', '_action', '_Route__index')
 
     nlri: NLRI
     attributes: AttributeCollection
+    _action: Action
     _Route__index: bytes
 
     @staticmethod
     def family_prefix(family: tuple[AFI, SAFI]) -> bytes:
         return b'%02x%02x' % family
 
-    def __init__(self, nlri: NLRI, attributes: AttributeCollection) -> None:
+    def __init__(self, nlri: NLRI, attributes: AttributeCollection, action: Action = Action.UNSET) -> None:
         self.nlri = nlri
         self.attributes = attributes
+        self._action = action
         # Index is computed lazily on first .index() call, not at __init__ time.
         # This is intentional: at construction time the NLRI may not be fully populated
         # (e.g., nexthop not yet set), which would cause api-attributes.sequence to fail.
         # The lazy evaluation ensures the index is computed only when all NLRI fields are set.
         self.__index = b''
 
+    @property
+    def action(self) -> Action:
+        """Get the route action (ANNOUNCE/WITHDRAW).
+
+        During transition: returns self._action if set, else falls back to nlri.action.
+        Eventually: will only return self._action.
+        """
+        if self._action != Action.UNSET:
+            return self._action
+        # Fallback to nlri.action during transition period
+        return self.nlri.action
+
+    @action.setter
+    def action(self, value: Action) -> None:
+        """Set the route action."""
+        self._action = value
+
     def index(self) -> bytes:
         if not self.__index:
             self.__index = b'%02x%02x' % self.nlri.family().afi_safi() + self.nlri.index()
@@ -71,5 +102,5 @@ class Route:
 
     def feedback(self) -> str:
         if self.nlri is not None:
-            return self.nlri.feedback(self.nlri.action)
+            return self.nlri.feedback(self.action)  # Use route.action, not nlri.action
         return 'no check implemented for the family {} {}'.format(*self.nlri.family().afi_safi())
