#!/usr/bin/env python3
# encoding: utf-8
"""
bgp

Created by Thomas Mangin
Copyright (c) 2013-2017 Exa Networks. All rights reserved.
License: 3-clause BSD. (See the COPYRIGHT file)
"""

import os
import socket
import sys
import time
import queue
import threading
import signal
import asyncio
import argparse
import hashlib

from struct import unpack, pack
from enum import Enum


# Global verbose flag - default True, set False by --terse
VERBOSE = True

# Session start time for elapsed timing
SESSION_START = None

# Message counter for tracking sequence
MSG_COUNTER = 0


def msg_hash(data):
    """Return short hash (6 chars) of message data"""
    if isinstance(data, str):
        data = data.encode()
    elif isinstance(data, (bytes, bytearray)):
        pass
    else:
        data = str(data).encode()
    return hashlib.md5(data).hexdigest()[:6]


def next_msg_num():
    """Return next message number"""
    global MSG_COUNTER
    MSG_COUNTER += 1
    return MSG_COUNTER


def reset_msg_counter():
    """Reset message counter for new session"""
    global MSG_COUNTER
    MSG_COUNTER = 0


class Color:
    """ANSI color codes for terminal output (only used when --verbose)"""

    RESET = '\033[0m'
    CYAN = '\033[36m'
    GREEN = '\033[32m'
    RED = '\033[31m'
    YELLOW = '\033[33m'
    MAGENTA = '\033[35m'
    BOLD = '\033[1m'
    DIM = '\033[2m'

    @classmethod
    def cyan(cls, text):
        return f'{cls.CYAN}{text}{cls.RESET}' if VERBOSE else text

    @classmethod
    def green(cls, text):
        return f'{cls.GREEN}{text}{cls.RESET}' if VERBOSE else text

    @classmethod
    def red(cls, text):
        return f'{cls.RED}{text}{cls.RESET}' if VERBOSE else text

    @classmethod
    def yellow(cls, text):
        return f'{cls.YELLOW}{text}{cls.RESET}' if VERBOSE else text

    @classmethod
    def magenta(cls, text):
        return f'{cls.MAGENTA}{text}{cls.RESET}' if VERBOSE else text

    @classmethod
    def bold(cls, text):
        return f'{cls.BOLD}{text}{cls.RESET}' if VERBOSE else text

    @classmethod
    def dim(cls, text):
        return f'{cls.DIM}{text}{cls.RESET}' if VERBOSE else text


def get_elapsed():
    """Return elapsed time since session start"""
    global SESSION_START
    if SESSION_START is None:
        SESSION_START = time.time()
    return time.time() - SESSION_START


def timestamp():
    """Return formatted timestamp string"""
    return f'[{get_elapsed():7.3f}s]' if VERBOSE else ''


# BGP Message type names
MSG_TYPES = {
    1: 'OPEN',
    2: 'UPDATE',
    3: 'NOTIFICATION',
    4: 'KEEPALIVE',
    5: 'ROUTE-REFRESH',
}

# BGP Path Attribute names
ATTR_NAMES = {
    1: 'ORIGIN',
    2: 'AS_PATH',
    3: 'NEXT_HOP',
    4: 'MED',
    5: 'LOCAL_PREF',
    6: 'ATOMIC_AGGR',
    7: 'AGGREGATOR',
    8: 'COMMUNITY',
    9: 'ORIGINATOR_ID',
    10: 'CLUSTER_LIST',
    14: 'MP_REACH_NLRI',
    15: 'MP_UNREACH_NLRI',
    16: 'EXT_COMMUNITY',
    17: 'AS4_PATH',
    18: 'AS4_AGGREGATOR',
    22: 'PMSI_TUNNEL',
    23: 'TUNNEL_ENCAP',
    25: 'TRAFFIC_ENG',
    26: 'IPV6_EXT_COMMUNITY',
    29: 'AIGP',
    32: 'LARGE_COMMUNITY',
    35: 'BGP_PREFIX_SID',
    40: 'ATTR_SET',
}

# Notification error codes
NOTIFY_CODES = {
    1: 'Message Header Error',
    2: 'OPEN Message Error',
    3: 'UPDATE Message Error',
    4: 'Hold Timer Expired',
    5: 'FSM Error',
    6: 'Cease',
}


class OutputBuffer:
    """Buffer output and print all at once to avoid interfering with asyncio"""

    def __init__(self):
        self.lines = []
        self.start_time = None

    def add(self, line):
        if self.start_time is None:
            self.start_time = time.time()
        elapsed = time.time() - self.start_time
        self.lines.append((elapsed, line))

    def flush(self):
        for elapsed, line in self.lines:
            if VERBOSE:
                flushed(f'[{elapsed:7.3f}s] {line}')
            else:
                flushed(line)
        self.lines = []


# Global run logger - set when --save is used
RUN_LOGGER = None


class RunLogger:
    """Log run data to file for later comparison"""

    def __init__(self, save_dir, test_name, config_path):
        self.save_dir = save_dir
        self.test_name = test_name
        self.config_path = config_path
        self.start_time = time.time()
        self.entries = []

        # Create directory if needed
        os.makedirs(save_dir, exist_ok=True)

        # Generate filename with timestamp
        timestamp = time.strftime('%Y%m%d-%H%M%S')
        self.filename = os.path.join(save_dir, f'{test_name}-{timestamp}.log')

    def log(self, event_type, msg_num=None, hash_val=None, msg_len=None, status=None, extra=None):
        """Log an event"""
        elapsed = time.time() - self.start_time
        entry = {
            'elapsed': elapsed,
            'type': event_type,
        }
        if msg_num is not None:
            entry['msg_num'] = msg_num
        if hash_val is not None:
            entry['hash'] = hash_val
        if msg_len is not None:
            entry['len'] = msg_len
        if status is not None:
            entry['status'] = status
        if extra is not None:
            entry['extra'] = extra
        self.entries.append(entry)

    def save(self, final_status):
        """Save log to file"""
        with open(self.filename, 'w') as f:
            f.write(f'# Test: {self.test_name}\n')
            f.write(f'# Date: {time.strftime("%Y-%m-%d %H:%M:%S")}\n')
            f.write(f'# Config: {self.config_path}\n')
            f.write(f'# Status: {final_status}\n')
            f.write('#\n')

            for entry in self.entries:
                elapsed = entry['elapsed']
                etype = entry['type']

                if etype == 'SESSION_START':
                    f.write(f'[{elapsed:7.3f}s] SESSION_START\n')
                elif etype == 'OPEN_RECV':
                    f.write(f'[{elapsed:7.3f}s] OPEN_RECV hash={entry.get("hash", "?")} len={entry.get("len", "?")}\n')
                elif etype == 'OPEN_SENT':
                    f.write(f'[{elapsed:7.3f}s] OPEN_SENT hash={entry.get("hash", "?")} len={entry.get("len", "?")}\n')
                elif etype == 'MSG':
                    status = entry.get('status', '?')
                    f.write(f'[{elapsed:7.3f}s] MSG #{entry.get("msg_num", "?")} hash={entry.get("hash", "?")} len={entry.get("len", "?")} {status}\n')
                elif etype == 'SESSION_END':
                    f.write(f'[{elapsed:7.3f}s] SESSION_END status={entry.get("status", "?")}\n')
                else:
                    f.write(f'[{elapsed:7.3f}s] {etype}\n')

        return self.filename


def init_run_logger(save_dir, test_name, config_path):
    """Initialize the global run logger"""
    global RUN_LOGGER
    if save_dir:
        RUN_LOGGER = RunLogger(save_dir, test_name, config_path)


def log_event(event_type, **kwargs):
    """Log an event if logger is active"""
    if RUN_LOGGER:
        RUN_LOGGER.log(event_type, **kwargs)


def save_run_log(final_status):
    """Save the run log and return filename"""
    if RUN_LOGGER:
        return RUN_LOGGER.save(final_status)
    return None


def format_hex_block(data, bytes_per_line=16):
    """Format hex data in a nice block with offset and ASCII"""
    if isinstance(data, str):
        # Convert hex string to bytes
        data = bytes.fromhex(data)

    lines = []
    for offset in range(0, len(data), bytes_per_line):
        chunk = data[offset : offset + bytes_per_line]
        hex_part = ' '.join(f'{b:02X}' for b in chunk)
        # Pad hex part to fixed width
        hex_part = hex_part.ljust(bytes_per_line * 3 - 1)
        # ASCII representation
        ascii_part = ''.join(chr(b) if 32 <= b < 127 else '.' for b in chunk)
        lines.append(f'  {offset:04X}  {hex_part}  |{ascii_part}|')
    return lines


def parse_bgp_message(header, body):
    """Parse BGP message and return structured info"""
    if isinstance(header, (bytes, bytearray)):
        header = bytestream(header)
    if isinstance(body, (bytes, bytearray)):
        body = bytestream(body)

    full_msg = header + body
    msg_bytes = bytes.fromhex(full_msg)

    # Header: 16 marker + 2 length + 1 type
    length = int(header[32:36], 16)
    msg_type = int(header[36:38], 16)
    type_name = MSG_TYPES.get(msg_type, f'UNKNOWN({msg_type})')

    result = {
        'type': msg_type,
        'type_name': type_name,
        'length': length,
        'raw': full_msg,
        'raw_bytes': msg_bytes,
        'details': [],
    }

    body_bytes = bytes.fromhex(body) if body else b''

    if msg_type == 1:  # OPEN
        result['details'] = parse_open(body_bytes)
    elif msg_type == 2:  # UPDATE
        result['details'] = parse_update(body_bytes)
    elif msg_type == 3:  # NOTIFICATION
        result['details'] = parse_notification(body_bytes)
    elif msg_type == 4:  # KEEPALIVE
        result['details'] = ['(no body)']

    return result


def parse_open(body):
    """Parse OPEN message body"""
    if len(body) < 10:
        return [f'Invalid OPEN (too short: {len(body)} bytes)']

    version = body[0]
    asn = (body[1] << 8) | body[2]
    hold_time = (body[3] << 8) | body[4]
    router_id = '.'.join(str(b) for b in body[5:9])
    opt_len = body[9]

    details = [
        f'Version: {version}',
        f'ASN: {asn}',
        f'Hold Time: {hold_time}s',
        f'Router ID: {router_id}',
        f'Opt Params: {opt_len} bytes',
    ]
    return details


def parse_update(body):
    """Parse UPDATE message body"""
    if len(body) < 4:
        if len(body) == 0:
            return ['(empty - EOR marker)']
        return [f'Invalid UPDATE (too short: {len(body)} bytes)']

    details = []
    offset = 0

    # Withdrawn routes length
    withdrawn_len = (body[0] << 8) | body[1]
    offset = 2
    details.append(f'Withdrawn: {withdrawn_len} bytes')

    if withdrawn_len > 0:
        withdrawn_data = body[offset : offset + withdrawn_len]
        routes = parse_nlri(withdrawn_data)
        for r in routes:
            details.append(f'  -{r}')
    offset += withdrawn_len

    # Path attributes length
    if offset + 2 > len(body):
        return details + ['(truncated)']

    attr_len = (body[offset] << 8) | body[offset + 1]
    offset += 2
    details.append(f'Path Attrs: {attr_len} bytes')

    if attr_len > 0:
        attr_data = body[offset : offset + attr_len]
        attrs = parse_attributes(attr_data)
        for a in attrs:
            details.append(f'  {a}')
    offset += attr_len

    # NLRI
    nlri_len = len(body) - offset
    if nlri_len > 0:
        details.append(f'NLRI: {nlri_len} bytes')
        nlri_data = body[offset:]
        routes = parse_nlri(nlri_data)
        for r in routes:
            details.append(f'  +{r}')
    elif nlri_len == 0 and withdrawn_len == 0 and attr_len == 0:
        details = ['EOR: IPv4 Unicast']

    return details


def parse_nlri(data):
    """Parse NLRI (prefix list)"""
    routes = []
    offset = 0
    while offset < len(data):
        prefix_len = data[offset]
        offset += 1
        prefix_bytes = (prefix_len + 7) // 8
        if offset + prefix_bytes > len(data):
            routes.append('(truncated)')
            break
        prefix_data = data[offset : offset + prefix_bytes]
        offset += prefix_bytes
        # Pad to 4 bytes for IPv4
        prefix_padded = prefix_data + b'\x00' * (4 - len(prefix_data))
        prefix = '.'.join(str(b) for b in prefix_padded[:4])
        routes.append(f'{prefix}/{prefix_len}')
    return routes


def parse_attributes(data):
    """Parse path attributes - just name, size, payload hex"""
    attrs = []
    offset = 0
    while offset < len(data):
        if offset + 2 > len(data):
            attrs.append('(truncated)')
            break

        flags = data[offset]
        type_code = data[offset + 1]
        offset += 2

        # Extended length?
        if flags & 0x10:
            if offset + 2 > len(data):
                attrs.append('(truncated)')
                break
            attr_len = (data[offset] << 8) | data[offset + 1]
            offset += 2
        else:
            if offset + 1 > len(data):
                attrs.append('(truncated)')
                break
            attr_len = data[offset]
            offset += 1

        attr_name = ATTR_NAMES.get(type_code, f'ATTR_{type_code}')

        if offset + attr_len > len(data):
            attrs.append(f'{attr_name}: {attr_len} bytes (truncated)')
            break

        payload = data[offset : offset + attr_len]
        payload_hex = ' '.join(f'{b:02X}' for b in payload[:16])
        if len(payload) > 16:
            payload_hex += '...'

        attrs.append(f'{attr_name}: {attr_len} bytes [{payload_hex}]')
        offset += attr_len

    return attrs


def parse_notification(body):
    """Parse NOTIFICATION message"""
    if len(body) < 2:
        return [f'Invalid NOTIFICATION (too short: {len(body)} bytes)']

    error_code = body[0]
    error_subcode = body[1]
    error_name = NOTIFY_CODES.get(error_code, f'Unknown({error_code})')

    details = [
        f'Error: {error_name}',
        f'Subcode: {error_subcode}',
    ]

    if len(body) > 2:
        data = body[2:]
        data_hex = ' '.join(f'{b:02X}' for b in data[:32])
        if len(data) > 32:
            data_hex += '...'
        details.append(f'Data: {len(data)} bytes [{data_hex}]')

    return details


def format_message_detailed(header, body, prefix=''):
    """Format a BGP message with full details - returns list of lines"""
    parsed = parse_bgp_message(header, body)
    lines = []

    # Header line with type and length
    type_colored = Color.cyan(parsed['type_name'])
    lines.append(f'{prefix}{type_colored} ({parsed["length"]} bytes)')

    # Details with tree structure
    details = parsed['details']
    for i, detail in enumerate(details):
        is_last = i == len(details) - 1
        prefix_char = '└─' if is_last else '├─'
        lines.append(f'{prefix}  {prefix_char} {detail}')

    # Raw hex block
    lines.append(f'{prefix}  Raw:')
    hex_lines = format_hex_block(parsed['raw_bytes'])
    for hl in hex_lines:
        lines.append(f'{prefix}  {hl}')

    return lines


class FSM(Enum):
    BUG = 0
    OPEN = 1
    MSG = 2
    STOP = 3


def bytestream(value):
    return ''.join(['%02X' % _ for _ in value])


def flushed(output):
    print(output)
    sys.stdout.flush()


def indent(msg, indent=12):
    sys.stdout.write(' ' * indent)
    flushed(msg)


def print_prefixed(prefix, message):
    flushed('{:12s}{}'.format(prefix, message))


# FIXME: we may be able to not have to use this
def msg_bytes(message):
    if len(message) % 2:
        flushed(f'invalid BGP message:\n    {message}')
    data = b''
    while message:
        b, message = message[:2], message[2:]
        value = int(b, 16)
        data += value.to_bytes(1, byteorder='big')
    return data


def format_message(header, body):
    return f'{header[:16]}:{header[16:18]}:{header[18:]}:{body}'


def print_payload(prefix, header, body):
    """Print BGP message with nice formatting"""
    if isinstance(header, (bytes, bytearray)):
        header_hex = bytestream(header)
    else:
        header_hex = header
    if isinstance(body, (bytes, bytearray)):
        body_hex = bytestream(body)
    else:
        body_hex = body

    full_hex = header_hex + body_hex

    # Parse message type and length from header
    msg_type = int(header_hex[36:38], 16) if len(header_hex) >= 38 else 0
    msg_len = int(header_hex[32:36], 16) if len(header_hex) >= 36 else 0
    type_name = MSG_TYPES.get(msg_type, f'TYPE_{msg_type}')

    # Header line: prefix + type + length
    type_colored = Color.cyan(type_name)
    flushed(f'{prefix:12}{type_colored} ({msg_len} bytes)')

    # Parse and show details based on message type
    body_bytes = bytes.fromhex(body_hex) if body_hex else b''

    if msg_type == 1:  # OPEN
        details = parse_open(body_bytes)
    elif msg_type == 2:  # UPDATE
        details = parse_update(body_bytes)
    elif msg_type == 3:  # NOTIFICATION
        details = parse_notification(body_bytes)
    elif msg_type == 4:  # KEEPALIVE
        details = []
    else:
        details = [f'{len(body_bytes)} bytes payload']

    # Print details with tree structure
    for i, detail in enumerate(details):
        is_last = i == len(details) - 1
        prefix_char = '└─' if is_last else '├─'
        flushed(f'{"":12}  {prefix_char} {detail}')

    # Print raw hex nicely
    raw_bytes = bytes.fromhex(full_hex)
    hex_lines = format_hex_block(raw_bytes)
    for hl in hex_lines:
        flushed(f'{"":12}{hl}')


def print_rule(prefix, rule):
    print_tab(prefix, f'{rule[:32]}:{rule[32:36]}:{rule[36:38]}:{rule[38:]}')


def print_tab(prefix, rule):
    flushed(f'{prefix:12}{rule}')


def dump(value):
    def spaced(value):
        even = None
        for v in value:
            if even is False:
                yield ' '
            yield '%02X' % v
            even = not even

    return ''.join(spaced(value))


def hex_diff(received, expected):
    """Show hex diff between received and expected messages (only in verbose mode)"""
    if not VERBOSE:
        return

    # Normalize to uppercase
    received = received.upper()
    expected = expected.upper()

    # Find first difference
    first_diff = -1
    for i in range(min(len(received), len(expected))):
        if received[i] != expected[i]:
            first_diff = i
            break

    if first_diff == -1 and len(received) != len(expected):
        first_diff = min(len(received), len(expected))

    if first_diff == -1:
        flushed(f'{timestamp()} {Color.green("Messages match")}')
        return

    # Format output showing difference location
    flushed(f'{timestamp()} {Color.red("First difference at byte offset")} {first_diff // 2}')

    # Show context around the difference (16 bytes before and after)
    ctx_start = max(0, (first_diff // 2 - 8) * 2)
    ctx_end = min(max(len(received), len(expected)), (first_diff // 2 + 8) * 2)

    # Build colored diff output
    recv_part = ''
    exp_part = ''
    for i in range(ctx_start, ctx_end, 2):
        r_byte = received[i : i + 2] if i + 2 <= len(received) else '--'
        e_byte = expected[i : i + 2] if i + 2 <= len(expected) else '--'

        if r_byte != e_byte:
            recv_part += Color.red(r_byte) + ' '
            exp_part += Color.green(e_byte) + ' '
        else:
            recv_part += Color.dim(r_byte) + ' '
            exp_part += Color.dim(e_byte) + ' '

    flushed(f'  received: {recv_part.strip()}')
    flushed(f'  expected: {exp_part.strip()}')


def cdr_to_length(cidr):
    if cidr > 24:
        return 4
    if cidr > 16:
        return 3
    if cidr > 8:
        return 2
    if cidr > 0:
        return 1
    return 0


def any_word_in_line(line, words):
    for word in words:
        if word in line:
            return True
    return False


def any_ends_in_line(line, words):
    for word in words:
        if line.endswith(word):
            return True
    return False


def any_word_in_list(searched, words):
    for word in words:
        for search in searched:
            if word in search:
                return True
    return False


def any_ends_in_list(searched, words):
    for word in words:
        for search in searched:
            if search.endswith(word):
                return True
    return False


def find_exabgp_pid():
    # --view is argv[1]
    conf_name = sys.argv[2].split('/')[-1].split('.')[0]

    processes = []
    cmdlines = []

    for line in os.popen('/bin/ps x'):
        low = line.strip().lower()
        if not low:
            continue

        if not any_word_in_line(low, ['/python ', '/python3 ', '/pypy ', '/pypy3 ']):
            continue

        cmdline = line.strip().split()[4:]
        pid = line.strip().split()[0]

        if len(cmdline) < 1:
            continue

        if not any_ends_in_list(cmdline, ['/main.py']):
            continue

        if not any_word_in_list(cmdline, [conf_name]):
            continue

        if not any_word_in_list(cmdline, ['.conf']):
            continue

        processes.append(pid)
        cmdlines.append(' '.join(cmdline))

    if len(processes) == 0:
        flushed('no process found, quitting')
        sys.exit(1)

    if len(processes) > 1:
        flushed('more than one process running, quitting')
        sys.exit(1)

    return processes[0], cmdlines[0]


def kill(signal_name='SIGUSR1'):
    names = [name for name in dir(signal) if name.startswith('SIG')]
    signals = dict([(name, getattr(signal, name)) for name in names])
    number = signals.get(signal_name.upper(), '')

    if not number:
        raise ValueError(f'invalid signal name: {signal_name}')

    pid, cmd_lime = find_exabgp_pid()

    flushed(f'\nsending signal {signal_name} to pid {pid}')
    flushed(f'pid {pid}: {cmd_lime}\n')

    try:
        os.kill(int(pid), number)
    except Exception as exc:
        flushed('\nfailed: %s' % str(exc))
        sys.exit(1)


class Message:
    @staticmethod
    def keepalive():
        return bytearray(
            [
                0xFF,
            ]
            * 16
            + [0x0, 0x13, 0x4]
        )

    @staticmethod
    def eor():
        return bytearray(
            [
                0xFF,
            ]
            * 16
            + [0x0, 0x17, 0x02]
            + [0x00, 0x00, 0x00, 0x00]
        )

    @staticmethod
    def default_route():
        return bytearray(
            [
                0xFF,
            ]
            * 16
            + [0x00, 0x31]
            + [
                0x02,
            ]
            + [0x00, 0x00]
            + [0x00, 0x15]
            + []
            + [0x40, 0x01, 0x01, 0x00]
            + []
            + [0x40, 0x02, 0x00]
            + []
            + [0x40, 0x03, 0x04, 0x7F, 0x00, 0x00, 0x01]
            + []
            + [0x40, 0x05, 0x04, 0x00, 0x00, 0x00, 0x64]
            + [0x20, 0x00, 0x00, 0x00, 0x00]
        )

    @staticmethod
    def notify(notification):
        return bytearray(
            [
                0xFF,
            ]
            * 16
            + [0x00, 19 + 2 + len(notification)]
            + [0x03]
            + [0x06]
            + [0x00]
        ) + notification.encode('utf-8')

    _name = {
        b'\x01': 'OPEN',
        b'\x02': 'UPDATE',
        b'\x03': 'NOTIFICATION',
        b'\x04': 'KEEPALIVE',
    }

    def __init__(self, header, body):
        self.header = header
        self.body = body

    def kind(self):
        return self.header[18]

    def is_open(self):
        return self.kind() == 1

    def is_update(self):
        return self.kind() == 2

    def is_notification(self):
        return self.kind() == 3

    def is_keepalive(self):
        return self.kind() == 4

    def is_route_refresh(self):
        return self.kind() == 5

    def is_eor(self):
        if not self.is_update():
            return False
        return len(self.body) in [4, 11]

    def name(self, header):
        return self._name.get(self.kind(), 'SOME WEIRD RFC PACKET')

    def notification(self):
        yield bytestream(self.body)
        # yield 'notification:%d,%d' % (self.body[0], self.body[1])

    def stream(self):
        return bytestream(self.header + self.body)

    def packet(self):
        return bytearray(self.header + self.body)

    def routes(self):
        body_len = len(self.body)

        len_w = unpack('!H', self.body[0:2])[0]
        withdrawn = bytearray([_ for _ in self.body[2 : 2 + len_w]])

        len_a = unpack('!H', self.body[2 + len_w : 2 + len_w + 2])[0]
        announced = bytearray([_ for _ in self.body[2 + len_w + 2 + len_a :]])

        if not withdrawn and not announced:
            if body_len == 4:
                yield 'eor:1:1'
            elif body_len == 11:
                yield 'eor:%d:%d' % (self.body[-2], self.body[-1])
            else:  # undecoded MP route
                yield 'mp:'
            return

        while withdrawn:
            cdr, withdrawn = withdrawn[0], withdrawn[1:]
            size = cdr_to_length(cdr)
            r = [0, 0, 0, 0]
            for index in range(size):
                r[index], withdrawn = withdrawn[0], withdrawn[1:]
            yield 'withdraw:%s' % '.'.join(str(_) for _ in r) + '/' + str(cdr)

        while announced:
            cdr, announced = announced[0], announced[1:]
            size = cdr_to_length(cdr)
            r = [0, 0, 0, 0]
            for index in range(size):
                r[index], announced = announced[0], announced[1:]
            yield 'announce:%s' % '.'.join(str(_) for _ in r) + '/' + str(cdr)

    @staticmethod
    def _add_capa66(adding, open):
        if not adding:
            return open

        # hack capability 66 into the message
        content = b'loremipsum'
        cap66 = bytearray([66, len(content)]) + content
        param = bytearray([2, len(cap66)]) + cap66
        return (
            open[:17]
            + bytearray([open[17] + len(param)])
            + open[18:28]
            + bytearray([open[28] + len(param)])
            + open[29:]
            + param
        )

    def open(self, asn, add_capa66):
        # lower byte of the router_id
        byte_id = self.body[8]

        if not asn:
            byte_id = bytearray([byte_id + 1 & 0xFF])
            open = self.header + self.body[:8] + byte_id + self.body[9:]
            return self._add_capa66(add_capa66, open)

        # Check if peer supports Four-Octet Autonomous System (RFC6793)
        opt_params = self.body[10:]
        offset = 0
        open = ''

        while offset < len(opt_params):
            param_type = opt_params[offset]
            param_len = opt_params[offset + 1]
            if param_type == 2:  # Capabilities Optional Parameter
                cap_code = opt_params[offset + 2]
                if cap_code == 65:  # Support for 4 octet AS number capability
                    open = (
                        self.header
                        + self.body[0:1]
                        + pack('!H', asn)
                        + self.body[3:8]
                        + pack('!H', byte_id)[1:]
                        + self.body[9:10]
                        + opt_params[: offset + 2 + 2]
                        + pack('!I', asn)
                        + opt_params[offset + 2 + 2 + 4 :]
                    )
                    return self._add_capa66(add_capa66, open)
            offset += param_len + 2

        # No "Support for 4 octet AS number capability" found simply replace the 16-bit ASN number field.
        open = self.header + self.body[0:1] + pack('!H', asn) + self.body[3:8] + pack('!H', byte_id)[1:] + self.body[9:]
        return self._add_capa66(add_capa66, open)


class Checker(object):
    updates_seen: list[str] = []

    def __init__(self, expected):
        self.raw = False
        self.messages = []

        self.sequences = self.group_messages(expected)

    def expecting(self):
        flushed('\nexpecting:')
        for message in self.messages:
            indent(message)

    def rules(self):
        """Show summary of expected messages"""
        total = sum(len(msgs) for msgs in self.sequences)
        flushed(f'expecting {total} message(s) in {len(self.sequences)} sequence(s)')

    # split all the messages and group them with the provided index
    # 1:raw:<raw bgp>
    # 1:raw:<raw bgp>
    # 2:raw:<raw bgp>
    # will return a list of two lists, first with 2 elements, second with one
    # A1:raw:<raw bgp>
    # B1:raw:<raw bgp>
    # B2:raw:<raw bgp>
    # C1:raw:<raw bgp>
    # is for when we have two different BGP connections

    # FIXME: we need to redo how we deal with raw vs parsed packets

    def group_messages(self, expected):
        group = {}
        for rule in expected:
            if 'notification:' not in rule:
                rule = rule.replace(' ', '').lower()

            try:
                prefix, encoding, content = rule.split(':', 2)
            except ValueError:
                flushed(f'invalid rule: {rule}')
                sys.exit(0)

            conn = prefix[0]
            if conn.isalpha():
                seq = int(prefix[1:])
            else:
                conn = 'A'
                seq = int(prefix)

            raw = encoding == 'raw'
            self.raw = self.raw or raw
            if raw:
                content = content.replace(':', '')
                group.setdefault(conn, {}).setdefault(seq, []).append(content.upper())
            else:
                group.setdefault(conn, {}).setdefault(seq, []).append(f'{encoding.lower()}:{content.lower()}')

        ordered = []
        for kg in sorted(list(group.keys())):
            source = group[kg]
            for ks in sorted(list(source.keys())):
                ordered.append(source[ks])
        return ordered

    def init(self):
        if self.messages:
            return False
        if not self.sequences:
            return False

        self.messages = self.sequences.pop(0)
        return self

    def _send_signal_if_requested(self):
        if not self.messages:
            return False

        if not self.messages[0].startswith('signal:'):
            return False

        message = self.messages.pop(0)
        self._update_messages_if_required()

        name = message.split(':')[-1]
        kill(name)
        return True

    def _send_notification_if_requested(self, writer):
        if not self.messages:
            return False

        if not self.messages[0].startswith('notification:'):
            return False

        notification = self.messages.pop(0).split(':')[-1]
        writer.write(Message.notify(notification))
        flushed(f'\nsending closing notification: "{notification}"\n')

        self._update_messages_if_required()
        return True

    def _send_rr_if_required(self, writer, msg):
        if msg.is_route_refresh():
            for header, body in self.updates_seen:
                print_payload('rr   sent', header, body)
                writer.write(Message(header, body).packet())
            writer.write(Message.keepalive())

    def perform_actions_if_required(self, writer, msg):
        self._update_messages_if_required()
        self._send_signal_if_requested()
        self._update_messages_if_required()
        self._send_notification_if_requested(writer)
        self._send_rr_if_required(writer, msg)

    def _update_messages_if_required(self):
        if not self.messages and self.sequences:
            self.messages = self.sequences.pop(0)

    def expected(self, writer, msg):
        if msg.is_keepalive():
            return True

        if not self.sequences and not self.messages:
            if msg.is_eor():
                return True
            flushed('received extra message')
            print_payload('additional', msg.header, msg.body)
            return False

        check = self.messages[0]
        stream = msg.stream()

        for check in self.messages:
            received = stream
            if not check.startswith('F' * 32) and ':' not in check:
                received = received[32:]

            if check == received:
                num_options = len(self.messages)
                self.messages.remove(check)
                if msg.is_update() and not msg.is_eor():
                    self.updates_seen.append((msg.header, msg.body))

                # Get message number and hash
                msg_num = next_msg_num()
                received_hex = bytestream(msg.header) + bytestream(msg.body)
                hash_val = msg_hash(received_hex)
                msg_len = len(msg.header) + len(msg.body)

                # Log the match
                log_event('MSG', msg_num=msg_num, hash_val=hash_val, msg_len=msg_len, status='MATCH')

                # Show expected and received together on match
                flushed('')
                ts = timestamp()
                header_line = f'msg #{msg_num} (hash: {hash_val})'
                flushed(f'{ts} {Color.green("─" * 20)} {header_line} {Color.green("─" * 20)}' if ts else f'{Color.green("─" * 20)} {header_line} {Color.green("─" * 20)}')

                if num_options == 1:
                    # Single expected - show it
                    check_bytes = msg_bytes(check)
                    flushed(f'{ts} {Color.dim("expected:")}' if ts else Color.dim('expected:'))
                    print_payload('', check_bytes[:19], check_bytes[19:])
                else:
                    # Multiple options - just show count
                    msg_text = Color.dim(f'expected: (matched 1 of {num_options} options)')
                    flushed(f'{ts} {msg_text}' if ts else msg_text)

                match_text = Color.green('received:') + ' ' + Color.green('✓ MATCH')
                flushed(f'{ts} {match_text}' if ts else match_text)
                print_payload('', msg.header, msg.body)

                self.perform_actions_if_required(writer, msg)
                return True

        # Mismatch - buffer all output and print at once
        buffer = OutputBuffer()
        nb_options = len(self.messages)
        received_hex = bytestream(msg.header) + bytestream(msg.body)

        # Get message number and hash for mismatch
        msg_num = next_msg_num()
        hash_val = msg_hash(received_hex)
        msg_len = len(msg.header) + len(msg.body)

        # Log the mismatch
        log_event('MSG', msg_num=msg_num, hash_val=hash_val, msg_len=msg_len, status='MISMATCH')

        buffer.add('')
        buffer.add(Color.red('=' * 60))
        buffer.add(Color.red(f'MESSAGE MISMATCH - msg #{msg_num} (hash: {hash_val})'))
        buffer.add(Color.red('=' * 60))

        # Received message - detailed view
        buffer.add('')
        buffer.add(Color.cyan('RECEIVED MESSAGE:'))
        for line in format_message_detailed(msg.header, msg.body, prefix='  '):
            buffer.add(line)

        # Expected options - detailed view
        buffer.add('')
        buffer.add(Color.green(f'EXPECTED OPTIONS ({nb_options}):'))
        for idx, message in enumerate(self.messages, 1):
            buffer.add(f'  Option {idx}:')
            msg_data = msg_bytes(message)
            for line in format_message_detailed(msg_data[:19], msg_data[19:], prefix='    '):
                buffer.add(line)

        # Hex diff for first option
        if self.messages:
            buffer.add('')
            buffer.add(Color.yellow('DIFFERENCE:'))
            # Inline hex_diff output to buffer
            expected_hex = self.messages[0].upper()
            received_upper = received_hex.upper()

            first_diff = -1
            for i in range(min(len(received_upper), len(expected_hex))):
                if received_upper[i] != expected_hex[i]:
                    first_diff = i
                    break
            if first_diff == -1 and len(received_upper) != len(expected_hex):
                first_diff = min(len(received_upper), len(expected_hex))

            if first_diff >= 0:
                buffer.add(f'  First difference at byte offset {first_diff // 2}')
                ctx_start = max(0, (first_diff // 2 - 8) * 2)
                ctx_end = min(max(len(received_upper), len(expected_hex)), (first_diff // 2 + 8) * 2)

                recv_part = ''
                exp_part = ''
                for i in range(ctx_start, ctx_end, 2):
                    r_byte = received_upper[i : i + 2] if i + 2 <= len(received_upper) else '--'
                    e_byte = expected_hex[i : i + 2] if i + 2 <= len(expected_hex) else '--'
                    if r_byte != e_byte:
                        recv_part += Color.red(r_byte) + ' '
                        exp_part += Color.green(e_byte) + ' '
                    else:
                        recv_part += Color.dim(r_byte) + ' '
                        exp_part += Color.dim(e_byte) + ' '
                buffer.add(f'  received: {recv_part.strip()}')
                buffer.add(f'  expected: {exp_part.strip()}')

        # Decode commands
        config_path = os.environ.get('EXABGP_TEST_CONFIG', '<config>')
        buffer.add('')
        buffer.add(Color.magenta('DECODE COMMANDS:'))
        buffer.add('  # Decode received:')
        buffer.add(f'  ./sbin/exabgp decode -c {config_path} "{received_hex}"')
        if self.messages:
            buffer.add('  # Decode expected option 1:')
            buffer.add(f'  ./sbin/exabgp decode -c {config_path} "{self.messages[0]}"')

        buffer.add('')
        buffer.add(Color.red('=' * 60))

        # Flush all buffered output at once
        buffer.flush()
        return False

    def completed(self):
        return len(self.messages) == 0 and len(self.sequences) == 0


class BGPService(object):
    def __init__(self, loop, queue, options, checker):
        self.options = options
        self.checker = checker
        self.loop = loop
        self.queue = queue

    def exit(self, code):
        self.queue.put(code)
        self.loop.stop()


class BGPProtocol(asyncio.Protocol):
    counter = 0

    def __init__(self, service, reader, writer):
        self.service = service
        self.reader = reader
        self.writer = writer

        if not service.checker.init():
            flushed('some messages are from previous session:')

    async def read_message(self):
        try:
            header = await self.reader.read(19)
        except BrokenPipeError:
            if self.service.checker.completed():
                self.service.exit(0)
            return '', ''
        except ConnectionResetError:
            if self.service.checker.completed():
                self.service.exit(0)
            return '', ''

        if not header:
            return '', ''

        length = unpack('!H', header[16:18])[0]
        body = await self.reader.read(length - 19)
        return header, body
        # return bytearray(header), bytearray(body)

    async def handle_bgp(self):
        state = FSM.OPEN
        while state != FSM.STOP:
            header, body = await self.read_message()
            if not header:
                await asyncio.sleep(1)
                continue

            msg = Message(header, body)

            if state == FSM.OPEN:
                reset_msg_counter()  # Reset message counter for new session
                log_event('SESSION_START')
                ts = timestamp()
                flushed(f'\n{ts} new session:' if ts else '\nnew session:')

                # Log OPEN received
                open_hex = bytestream(header) + bytestream(body)
                log_event('OPEN_RECV', hash_val=msg_hash(open_hex), msg_len=len(header) + len(body))

                print_payload('open recv', header, body)
                state = self.handle_open(msg)
                continue

            if state == FSM.MSG:
                # Don't print here - expected() will show expected vs received
                state = self.handle_message(msg)
                continue

            flushed(f'FSM issue {state}')
            sys.exit(1)
        self.writer.close()

    def handle_open(self, msg):
        option_asn = self.service.options['asn']
        option_capa66 = self.service.options['send-unknown-capability']
        option_default = self.service.options['send-default-route']
        option_open = self.service.options['inspect-open-message']
        option_unknown = self.service.options['send-unknown-message']

        open = msg.open(option_asn, option_capa66)
        # Log OPEN sent
        log_event('OPEN_SENT', hash_val=msg_hash(open), msg_len=len(open))
        print_payload('open sent', open[:19], open[19:])
        self.writer.write(open)
        self.writer.write(Message.keepalive())
        if option_unknown:
            # send an invalid/unknown BGP message type to exercise error handling
            unknown = b'\xff' * 16 + pack('!H', 19) + bytes([255])
            self.writer.write(unknown)

        if option_open:
            if not self.service.checker.expected(self.writer, msg):
                self.service.exit(1)
                return FSM.STOP

            if self.service.checker.completed():
                self.service.exit(0)
                return FSM.STOP

            return FSM.MSG

        self.service.checker.perform_actions_if_required(self.writer, msg)

        if option_default:
            flushed('sending default-route\n')
            self.writer.write(Message.default_route())

        return FSM.MSG

    def handle_message(self, msg):
        self.counter += 1
        header, body = msg.header, msg.body

        if self.service.options['sink']:
            print_payload(f'sank     #{self.counter}', header, body)
            self.writer.write(Message.keepalive())
            return FSM.MSG

        if self.service.options['echo']:
            print_payload(f"echo'd  #{self.counter}", header, body)
            self.writer.write(header + body)
            return FSM.MSG

        # saving update saved to send them later on rr test

        self.writer.write(Message.keepalive())

        if not self.service.checker.expected(self.writer, msg):
            self.service.exit(1)
            return FSM.STOP

        if self.service.checker.completed():
            self.service.exit(0)
            return FSM.STOP

        return FSM.MSG


def parse_cmdline():
    port = os.environ.get('exabgp.tcp.port', os.environ.get('exabgp_tcp_port', '179'))

    parser = argparse.ArgumentParser(add_help=False)
    parser.add_argument('--help', help='this help :-)', action='store_true')
    parser.add_argument(
        '--echo',
        help='accept any BGP messages send it back to the emiter',
        action='store_true',
    )
    parser.add_argument(
        '--sink',
        help='accept any BGP messages and reply with a keepalive',
        action='store_true',
    )
    parser.add_argument(
        '--asn',
        help='ASN to use (otherwise extracted from the OPEN)',
        type=int,
        default=None,
    )
    parser.add_argument('--port', help='port to bind to', type=int, default=port)
    parser.add_argument('--view', help='look at the expected packets', action='store_true')
    parser.add_argument('--terse', help='disable colors and timing info', action='store_true')
    parser.add_argument('--save', help='save run log to directory', type=str, default=None)
    parser.add_argument('--ipv6', help='bind using ipv6', action='store_true')
    parser.add_argument(
        'checks',
        help='a list of expected route announcement/withdrawl',
        nargs='?',
        type=open,
    )

    cmdarg = parser.parse_args()

    # Don't allow 4-byte ASN, as peer maybe not supports 4-byte asn
    if (
        cmdarg.help
        or cmdarg.port <= 0
        or cmdarg.port > 65535
        or cmdarg.asn is not None
        and (cmdarg.asn < 0 or cmdarg.asn > 65535)
    ):
        parser.print_help()
        sys.exit(1)

    # fmt: off
    options = {
        'send-unknown-capability': False,  # add an unknown capability to the open message
        'send-default-route': False,       # send a default route to the peer
        'inspect-open-message': False,     # check for received OPEN message
        'send-unknown-message': False,     # send an unknown message type to the peer
        'asn': None,                       # Don't modify the local AS per default.
        'sink': False,                     # just accept whatever is sent
        'echo': False,                     # just accept whatever is sent
        'ipv6': False,                     # bind to ipv4 by default
        'expect': []
    }

    options.update({
        'sink': cmdarg.sink,
        'echo': cmdarg.echo,
        'port': cmdarg.port,
        'asn': cmdarg.asn,
        'ipv6': cmdarg.ipv6,
        'view': cmdarg.view,
        'terse': cmdarg.terse,
        'save': cmdarg.save,
    })
    # fmt: on

    if not cmdarg.checks:
        return options

    content = [_.strip() for _ in cmdarg.checks.readlines() if _.strip() and '#' not in _]
    expect = []
    for message in content:
        if message.strip() == 'option:bind:ipv6':
            options['ipv6'] = True
            continue
        if message.strip() == 'option:open:send-unknown-capability':
            options['send-unknown-capability'] = True
            continue
        if message.strip() == 'option:open:inspect-open-message':
            options['inspect-open-message'] = True
            continue
        if message.strip() == 'option:update:send-default-route':
            options['send-default-route'] = True
            continue
        if message.strip().startswith('option:asn:'):
            options['asn'] = int(message.strip().split(':')[-1])
            continue
        if message.strip() == 'option:open:send-unknown-message':
            options['send-unknown-message'] = True
            continue
        if message.strip().startswith('option:tcp_connections:'):
            options['tcp_connections'] = int(message.strip().split(':')[-1])
            continue
        if message.strip().startswith('option:SIGUSR1:'):
            delay = int(message.split(':')[-1])
            myself = os.getpid()

            def suicide(delay, myself):
                time.sleep(delay)
                signal(myself)
                time.sleep(10)

            threading.Thread(target=suicide, args=(delay, myself))

        expect.append(message)

    options['expect'] = expect
    return options


async def main(options, checker, queue):
    # self.set_reuse_addr()
    # self.bind((host, options['port']))
    # self.listen(5)

    if options['sink']:
        flushed('\nsink mode - send us whatever, we can take it ! :p\n')
    elif options['echo']:
        flushed('\necho mode - send us whatever, we can parrot it ! :p\n')
    elif not options['expect']:
        flushed('no test data available to test against')
        sys.exit(1)

    sock = socket.socket(socket.AF_INET6, socket.SOCK_STREAM)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)
    try:
        host = '::1' if options['ipv6'] else '::FFFF:127.0.0.1'
        port = options['port']
        sock.bind((host, port))
    except (PermissionError, OSError) as exc:
        flushed(f'could not bind to {host}:{port}')
        flushed(exc)
        sys.exit(1)

    loop = asyncio.get_running_loop()
    service = BGPService(loop, queue, options, checker)

    server = await asyncio.start_server(
        lambda reader, writer: BGPProtocol(service, reader, writer).handle_bgp(),
        sock=sock,
    )
    # perhaps set backlog to 1 ..

    async with server:
        await server.serve_forever()


def set_verbose(value):
    """Set global VERBOSE flag"""
    global VERBOSE
    VERBOSE = value


if __name__ == '__main__':
    options = parse_cmdline()

    # Set global verbose flag for color and timing output (default: True)
    # Use --terse to disable colors and timing
    set_verbose(not options.get('terse', False))

    # Initialize run logger if --save is specified
    if options.get('save'):
        test_name = os.environ.get('EXABGP_TEST_NAME', 'unknown')
        config_path = os.environ.get('EXABGP_TEST_CONFIG', 'unknown')
        init_run_logger(options['save'], test_name, config_path)

    checker = Checker(options['expect'])

    if options['view']:
        flushed('')
        checker.rules()

    result_queue: queue.Queue[int] = queue.Queue()
    try:
        asyncio.run(main(options, checker, result_queue))
    except RuntimeError:
        pass

    flushed('\n')

    if result_queue.empty():
        flushed('failed with no code')
        log_file = save_run_log('FAILED_NO_CODE')
        if log_file:
            flushed(f'Run log saved to: {log_file}')
        sys.exit(1)

    code = result_queue.get()
    if code != 0:
        flushed(f'failed with code {code}')
        log_file = save_run_log(f'FAILED_{code}')
        if log_file:
            flushed(f'Run log saved to: {log_file}')
        sys.exit(code)

    log_file = save_run_log('SUCCESS')
    if log_file:
        flushed(f'Run log saved to: {log_file}')
    flushed('successful')
    sys.exit(0)
