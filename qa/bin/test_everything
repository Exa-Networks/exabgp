#!/usr/bin/env python3
"""
ExaBGP Complete Test Suite Runner

Runs all required tests in sequence, exits on first failure.
Use this instead of running individual test commands.

Exit codes:
  0 - All tests passed
  N - Test N failed (position in test list)
"""

import os
import re
import sys
import subprocess
import time
from typing import Tuple, Optional, Callable


class Colors:
    """ANSI color codes"""
    GREEN = '\033[92m'
    RED = '\033[91m'
    YELLOW = '\033[93m'
    CYAN = '\033[96m'
    BOLD = '\033[1m'
    RESET = '\033[0m'

    @classmethod
    def disable(cls):
        """Disable colors for non-TTY output"""
        cls.GREEN = ''
        cls.RED = ''
        cls.YELLOW = ''
        cls.CYAN = ''
        cls.BOLD = ''
        cls.RESET = ''


# Disable colors if not in a TTY
if not sys.stdout.isatty():
    Colors.disable()


def print_header(test_num: int, total: int, message: str) -> None:
    """Print a test section header"""
    print(f"\n{Colors.BOLD}{Colors.CYAN}{'=' * 70}{Colors.RESET}")
    print(f"{Colors.BOLD}{Colors.CYAN}TEST {test_num}/{total}: {message}{Colors.RESET}")
    print(f"{Colors.BOLD}{Colors.CYAN}{'=' * 70}{Colors.RESET}\n")


def print_success(message: str) -> None:
    """Print success message"""
    print(f"{Colors.GREEN}✓ {message}{Colors.RESET}")


def print_error(message: str) -> None:
    """Print error message"""
    print(f"{Colors.RED}✗ {message}{Colors.RESET}")


def print_info(message: str) -> None:
    """Print info message"""
    print(f"{Colors.YELLOW}→ {message}{Colors.RESET}")


def run_command(cmd: str, env: Optional[dict] = None, shell: bool = True) -> Tuple[int, str, str]:
    """
    Run a command and return exit code, stdout, stderr

    Args:
        cmd: Command to run
        env: Optional environment variables to add
        shell: Whether to run in shell mode

    Returns:
        Tuple of (exit_code, stdout, stderr)
    """
    # Merge environment
    full_env = os.environ.copy()
    if env:
        full_env.update(env)

    # Run command
    process = subprocess.Popen(
        cmd,
        shell=shell,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        env=full_env,
        text=True
    )

    stdout, stderr = process.communicate()
    return process.returncode, stdout, stderr


def test_ruff_format(test_num: int, total: int) -> bool:
    """Ruff format check"""
    print_header(test_num, total, "Ruff Format")
    print_info("Running: ruff format src tests")

    returncode, stdout, stderr = run_command("ruff format src tests")

    if returncode != 0:
        print_error("Ruff format failed")
        if stdout:
            print(stdout)
        if stderr:
            print(stderr)
        return False

    # Check if files were reformatted
    if stdout.strip() and "files" in stdout.lower():
        print_info(stdout.strip())

    print_success("Ruff format passed")
    return True


def test_ruff_check(test_num: int, total: int) -> bool:
    """Ruff check"""
    print_header(test_num, total, "Ruff Check")
    print_info("Running: ruff check src qa tests")

    returncode, stdout, stderr = run_command("ruff check src qa tests")

    if returncode != 0:
        print_error("Ruff check failed")
        if stdout:
            print(stdout)
        if stderr:
            print(stderr)
        return False

    print_success("Ruff check passed - All checks passed!")
    return True


def test_unit_tests(test_num: int, total: int) -> bool:
    """Unit tests"""
    print_header(test_num, total, "Unit Tests")
    print_info("Running: pytest ./tests/unit/")

    returncode, stdout, stderr = run_command(
        "env exabgp_log_enable=false pytest ./tests/unit/ -q",
        shell=True
    )

    if returncode != 0:
        print_error("Unit tests failed")
        print(stdout)
        if stderr:
            print(stderr)
        return False

    # Extract test count from output
    lines = stdout.strip().split('\n')
    summary_line = lines[-1] if lines else ""

    print_success(f"Unit tests passed - {summary_line}")
    return True


def test_config_validation(test_num: int, total: int) -> bool:
    """Configuration validation"""
    print_header(test_num, total, "Configuration Validation")
    print_info("Running: ./sbin/exabgp validate -nrv ./etc/exabgp/conf-ipself6.conf")

    returncode, stdout, stderr = run_command(
        "./sbin/exabgp validate -nrv ./etc/exabgp/conf-ipself6.conf"
    )

    if returncode != 0:
        print_error("Configuration validation failed")
        if stdout:
            print(stdout)
        if stderr:
            print(stderr)
        return False

    print_success("Configuration validation passed")
    return True


def test_no_neighbor(test_num: int, total: int) -> bool:
    """No-neighbor API-only mode"""
    print_header(test_num, total, "No-Neighbor API Test")
    print_info("Running: qa/scripts/test_no_neighbor.py")

    returncode, stdout, stderr = run_command("./qa/scripts/test_no_neighbor.py")

    # Print output
    print(stdout)
    if stderr:
        print(stderr)

    if returncode != 0:
        print_error("No-neighbor test failed")
        return False

    print_success("No-neighbor test passed - API works without BGP neighbors")
    return True


def test_type_ignore_regression(test_num: int, total: int) -> bool:
    """Type ignore regression check"""
    print_header(test_num, total, "Type Ignore Regression Check")
    print_info("Running: ./qa/bin/check_type_ignores")

    returncode, stdout, stderr = run_command("./qa/bin/check_type_ignores")

    # Print output
    print(stdout)
    if stderr:
        print(stderr)

    if returncode != 0:
        print_error("Type ignore regression check failed - count increased above baseline")
        return False

    print_success("Type ignore regression check passed")
    return True


def test_functional_encoding(test_num: int, total: int) -> bool:
    """Functional encoding tests (async mode - default)"""
    print_header(test_num, total, "Functional Encoding Tests (Async Mode - Default)")
    print_info("Running: ./qa/bin/functional encoding (72 tests)")

    # Kill any leftover processes first
    subprocess.run("killall -9 python 2>/dev/null", shell=True)
    time.sleep(0.5)

    returncode, stdout, stderr = run_command("./qa/bin/functional encoding")

    # Print output to show progress
    print(stdout)
    if stderr:
        print(stderr)

    if returncode != 0:
        print_error("Functional encoding tests (async) failed")
        return False

    # Check for 100% pass rate - look for "100.0% passed" or similar on same line
    pass_rate_match = re.search(r'100(?:\.\d+)?%\s+passed', stdout)
    if pass_rate_match:
        # Also verify no failures
        failed_match = re.search(r'failed\s+(\d+)', stdout, re.IGNORECASE)
        if failed_match and int(failed_match.group(1)) > 0:
            print_error("Functional encoding tests (async) had failures")
            return False

        print_success("Functional encoding tests (async) passed - All 72 tests passed")
        return True
    else:
        print_error("Functional encoding tests (async) did not achieve 100% pass rate")
        return False


def test_functional_encoding_legacy(test_num: int, total: int) -> bool:
    """Functional encoding tests (legacy/sync mode)"""
    print_header(test_num, total, "Functional Encoding Tests (Legacy Mode)")
    print_info("Running: env exabgp_reactor_legacy=true ./qa/bin/functional encoding (72 tests)")

    # Kill any leftover processes first
    subprocess.run("killall -9 python 2>/dev/null", shell=True)
    time.sleep(0.5)

    returncode, stdout, stderr = run_command(
        "./qa/bin/functional encoding",
        env={"exabgp_reactor_legacy": "true"}
    )

    # Print output to show progress
    print(stdout)
    if stderr:
        print(stderr)

    if returncode != 0:
        print_error("Functional encoding tests (legacy) failed")
        return False

    # Check for 100% pass rate - look for "100.0% passed" or similar on same line
    pass_rate_match = re.search(r'100(?:\.\d+)?%\s+passed', stdout)
    if pass_rate_match:
        # Also verify no failures
        failed_match = re.search(r'failed\s+(\d+)', stdout, re.IGNORECASE)
        if failed_match and int(failed_match.group(1)) > 0:
            print_error("Functional encoding tests (legacy) had failures")
            return False

        print_success("Functional encoding tests (legacy) passed - All 72 tests passed")
        return True
    else:
        print_error("Functional encoding tests (legacy) did not achieve 100% pass rate")
        return False


def test_functional_decoding(test_num: int, total: int) -> bool:
    """Functional decoding tests"""
    print_header(test_num, total, "Functional Decoding Tests")
    print_info("Running: ./qa/bin/functional decoding")

    returncode, stdout, stderr = run_command("./qa/bin/functional decoding")

    # Print output to show progress
    print(stdout)
    if stderr:
        print(stderr)

    if returncode != 0:
        print_error("Functional decoding tests failed")
        return False

    print_success("Functional decoding tests passed")
    return True


def main() -> int:
    """Run all tests in sequence"""
    print(f"{Colors.BOLD}ExaBGP Complete Test Suite{Colors.RESET}")
    print(f"{Colors.BOLD}Running all required tests...{Colors.RESET}")

    start_time = time.time()

    # Run all tests in sequence - functional tests last
    tests: list[Callable[[int, int], bool]] = [
        test_ruff_format,
        test_ruff_check,
        test_unit_tests,
        test_config_validation,
        test_no_neighbor,
        test_functional_decoding,
        test_functional_encoding,
        test_functional_encoding_legacy,
        test_type_ignore_regression,
    ]

    total = len(tests)
    for i, test_func in enumerate(tests, start=1):
        success = test_func(i, total)
        if not success:
            elapsed = time.time() - start_time
            print(f"\n{Colors.RED}{Colors.BOLD}FAILED{Colors.RESET} after {elapsed:.1f}s")
            print(f"{Colors.RED}Exit code: {i}{Colors.RESET}")
            return i

    # All tests passed
    elapsed = time.time() - start_time
    print_header(total, total, "ALL TESTS PASSED")
    print(f"{Colors.GREEN}{Colors.BOLD}✓ All {total} test suites passed in {elapsed:.1f}s{Colors.RESET}")
    print(f"\n{Colors.GREEN}Async (default) and legacy modes both pass 100%{Colors.RESET}")
    print(f"{Colors.GREEN}Code is ready for commit{Colors.RESET}\n")

    return 0


if __name__ == "__main__":
    try:
        sys.exit(main())
    except KeyboardInterrupt:
        print(f"\n{Colors.YELLOW}Interrupted by user{Colors.RESET}")
        sys.exit(130)
    except Exception as e:
        print(f"\n{Colors.RED}Unexpected error: {e}{Colors.RESET}")
        sys.exit(255)
