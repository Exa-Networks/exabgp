#!/usr/bin/env python3
"""
ExaBGP Complete Test Suite Runner

Runs all required tests in sequence, exits on first failure.
Use this instead of running individual test commands.

Exit codes:
  0 - All tests passed
  N - Test N failed (position in test list)
"""

import os
import re
import sys
import subprocess
import time
from typing import Tuple, Optional, Callable


class Colors:
    """ANSI color codes"""

    GREEN = '\033[92m'
    RED = '\033[91m'
    YELLOW = '\033[93m'
    CYAN = '\033[96m'
    BOLD = '\033[1m'
    RESET = '\033[0m'

    @classmethod
    def disable(cls):
        """Disable colors for non-TTY output"""
        cls.GREEN = ''
        cls.RED = ''
        cls.YELLOW = ''
        cls.CYAN = ''
        cls.BOLD = ''
        cls.RESET = ''


# Disable colors if not in a TTY
if not sys.stdout.isatty():
    Colors.disable()


def print_header(test_num: int, total: int, message: str) -> None:
    """Print a test section header"""
    print(f'\n{Colors.BOLD}{Colors.CYAN}{"=" * 70}{Colors.RESET}')
    print(f'{Colors.BOLD}{Colors.CYAN}TEST {test_num}/{total}: {message}{Colors.RESET}')
    print(f'{Colors.BOLD}{Colors.CYAN}{"=" * 70}{Colors.RESET}\n')


def print_success(message: str) -> None:
    """Print success message"""
    print(f'{Colors.GREEN}✓ {message}{Colors.RESET}')


def print_error(message: str) -> None:
    """Print error message"""
    print(f'{Colors.RED}✗ {message}{Colors.RESET}')


def print_info(message: str) -> None:
    """Print info message"""
    print(f'{Colors.YELLOW}→ {message}{Colors.RESET}')


def run_command(cmd: str, env: Optional[dict] = None, shell: bool = True) -> Tuple[int, str, str]:
    """
    Run a command and return exit code, stdout, stderr

    Args:
        cmd: Command to run
        env: Optional environment variables to add
        shell: Whether to run in shell mode

    Returns:
        Tuple of (exit_code, stdout, stderr)
    """
    # Merge environment
    full_env = os.environ.copy()
    if env:
        full_env.update(env)

    # Run command
    process = subprocess.Popen(
        cmd, shell=shell, stdout=subprocess.PIPE, stderr=subprocess.PIPE, env=full_env, text=True
    )

    stdout, stderr = process.communicate()
    return process.returncode, stdout, stderr


def test_ruff_format(test_num: int, total: int) -> bool:
    """Ruff format check"""
    returncode, stdout, stderr = run_command('uv run ruff format src tests')

    if returncode != 0:
        print_header(test_num, total, 'Ruff Format')
        print_error('Ruff format failed')
        if stdout:
            print(stdout)
        if stderr:
            print(stderr)
        return False

    return True


def test_ruff_check(test_num: int, total: int) -> bool:
    """Ruff check"""
    returncode, stdout, stderr = run_command('uv run ruff check src qa tests')

    if returncode != 0:
        print_header(test_num, total, 'Ruff Check')
        print_error('Ruff check failed')
        if stdout:
            print(stdout)
        if stderr:
            print(stderr)
        return False

    return True


def test_unit_tests(test_num: int, total: int) -> bool:
    """Unit tests"""
    returncode, stdout, stderr = run_command('env exabgp_log_enable=false uv run pytest ./tests/unit/ -q', shell=True)

    if returncode != 0:
        print_header(test_num, total, 'Unit Tests')
        print_error('Unit tests failed')
        print(stdout)
        if stderr:
            print(stderr)
        return False

    return True


def test_config_validation(test_num: int, total: int) -> bool:
    """Configuration validation"""
    returncode, stdout, stderr = run_command('./sbin/exabgp validate -nrv ./etc/exabgp/conf-ipself6.conf')

    if returncode != 0:
        print_header(test_num, total, 'Configuration Validation')
        print_error('Configuration validation failed')
        if stdout:
            print(stdout)
        if stderr:
            print(stderr)
        return False

    return True


def test_no_neighbor(test_num: int, total: int) -> bool:
    """No-neighbor API-only mode"""
    returncode, stdout, stderr = run_command('./qa/scripts/test_no_neighbor.py')

    if returncode != 0:
        print_header(test_num, total, 'No-Neighbor API Test')
        print_error('No-neighbor test failed')
        print(stdout)
        if stderr:
            print(stderr)
        return False

    return True


def test_encode_decode(test_num: int, total: int) -> bool:
    """Encode/decode CLI commands"""
    returncode, stdout, stderr = run_command('./qa/scripts/test_encode_decode.py')

    if returncode != 0:
        print_header(test_num, total, 'Encode/Decode CLI Test')
        print_error('Encode/decode test failed')
        print(stdout)
        if stderr:
            print(stderr)
        return False

    return True


def test_type_ignore_regression(test_num: int, total: int) -> bool:
    """Type ignore regression check"""
    returncode, stdout, stderr = run_command('./qa/bin/check_type_ignores')

    if returncode != 0:
        print_header(test_num, total, 'Type Ignore Regression Check')
        print_error('Type ignore regression check failed - count increased above baseline')
        print(stdout)
        if stderr:
            print(stderr)
        return False

    return True


def test_functional_encoding(test_num: int, total: int) -> bool:
    """Functional encoding tests (async mode - default)"""
    # Kill any leftover processes first
    subprocess.run('killall -9 python 2>/dev/null', shell=True)
    time.sleep(0.5)

    returncode, stdout, stderr = run_command('./qa/bin/functional encoding --quiet')

    if returncode != 0:
        print_header(test_num, total, 'Functional Encoding Tests (Async Mode)')
        print_error('Functional encoding tests (async) failed')
        print(stdout)
        if stderr:
            print(stderr)
        return False

    # Check for 100% pass rate - quiet mode outputs "passed N/N (100.0%)"
    pass_rate_match = re.search(r'100(?:\.\d+)?%', stdout)
    if not pass_rate_match:
        print_header(test_num, total, 'Functional Encoding Tests (Async Mode)')
        print_error('Functional encoding tests (async) did not achieve 100% pass rate')
        print(stdout)
        return False

    return True


def test_functional_encoding_legacy(test_num: int, total: int) -> bool:
    """Functional encoding tests (legacy/sync mode)"""
    # Kill any leftover processes first
    subprocess.run('killall -9 python 2>/dev/null', shell=True)
    time.sleep(0.5)

    returncode, stdout, stderr = run_command(
        './qa/bin/functional encoding --quiet', env={'exabgp_reactor_legacy': 'true'}
    )

    if returncode != 0:
        print_header(test_num, total, 'Functional Encoding Tests (Legacy Mode)')
        print_error('Functional encoding tests (legacy) failed')
        print(stdout)
        if stderr:
            print(stderr)
        return False

    # Check for 100% pass rate - quiet mode outputs "passed N/N (100.0%)"
    pass_rate_match = re.search(r'100(?:\.\d+)?%', stdout)
    if not pass_rate_match:
        print_header(test_num, total, 'Functional Encoding Tests (Legacy Mode)')
        print_error('Functional encoding tests (legacy) did not achieve 100% pass rate')
        print(stdout)
        return False

    return True


def test_functional_decoding(test_num: int, total: int) -> bool:
    """Functional decoding tests"""
    returncode, stdout, stderr = run_command('./qa/bin/functional decoding')

    if returncode != 0:
        print_header(test_num, total, 'Functional Decoding Tests')
        print_error('Functional decoding tests failed')
        print(stdout)
        if stderr:
            print(stderr)
        return False

    return True


def main() -> int:
    """Run all tests in sequence"""
    start_time = time.time()

    # Run all tests in sequence - functional tests last
    tests: list[Callable[[int, int], bool]] = [
        test_ruff_format,
        test_ruff_check,
        test_unit_tests,
        test_config_validation,
        test_no_neighbor,
        test_encode_decode,
        test_functional_decoding,
        test_functional_encoding,
        test_functional_encoding_legacy,
        test_type_ignore_regression,
    ]

    total = len(tests)
    for i, test_func in enumerate(tests, start=1):
        success = test_func(i, total)
        if not success:
            elapsed = time.time() - start_time
            print(f'\n{Colors.RED}{Colors.BOLD}FAILED{Colors.RESET} after {elapsed:.1f}s')
            print(f'{Colors.RED}Exit code: {i}{Colors.RESET}')
            return i

    # All tests passed - single line output
    elapsed = time.time() - start_time
    print(f'{Colors.GREEN}✓ All {total} test suites passed in {elapsed:.1f}s{Colors.RESET}')

    return 0


if __name__ == '__main__':
    try:
        sys.exit(main())
    except KeyboardInterrupt:
        print(f'\n{Colors.YELLOW}Interrupted by user{Colors.RESET}')
        sys.exit(130)
    except Exception as e:
        print(f'\n{Colors.RED}Unexpected error: {e}{Colors.RESET}')
        sys.exit(255)
